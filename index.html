<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- New Theme Color Meta Tag -->
    <meta name="theme-color" content="#1a1a2e">
    <title>Werwolf Manager</title>
    <!-- SVG Favicon -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cstyle%3E path %7B fill: %23e94560; %7D @media (prefers-color-scheme: dark) %7B path %7B fill: %23e0e0fc; %7D %7D %3C/style%3E%3Cpath d='M50 5 C 25 5, 10 25, 10 50 S 25 95, 50 95 S 90 75, 90 50 S 75 5, 50 5 z M 50 15 A 35 35 0 0 1 85 50 A 35 35 0 0 1 50 85 A 35 35 0 0 1 15 50 A 35 35 0 0 1 50 15 z M 40 35 A 5 5 0 0 0 35 40 L 35 60 A 5 5 0 0 0 40 65 L 60 65 A 5 5 0 0 0 65 60 L 65 40 A 5 5 0 0 0 60 35 L 40 35 z M 50 42 L 58 58 L 42 58 L 50 42 z'/%3E%3C/svg%3E" type="image/svg+xml">
    <!-- Google Fonts Import -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- Basic Reset & Theme --- */
        :root {
            /* Updated Color Palette */
            --bg-color: #1a1a2e; /* Deep Midnight Blue */
            --container-bg: #2a2a4e; /* Slightly Lighter Indigo */
            --card-bg: #353560; /* Role card background */
            --text-color: #e0e0fc; /* Lavender Grey */
            --primary-color: #e94560; /* Vibrant Crimson/Rose */
            --button-bg: #4a4a7a; /* Muted Indigo */
            --button-hover-bg: #63639c; /* Brighter Muted Indigo */
            --input-bg: #2f2f5a; /* Dark Indigo */
            --border-color: #4a4a7a; /* Muted Indigo */
            --error-color: #ff6b6b; /* Keep original */
            --info-icon-color: #a259ff; /* Mystic Purple for info button */
            --disabled-opacity: 0.5; /* Adjusted for contrast */
            --dead-opacity: 0.5;
            --geist-color: #aaa;
            --selected-bg: rgba(233, 69, 96, 0.2); /* Crimson overlay */
            --info-bg: rgba(255, 255, 255, 0.05); /* Subtle white overlay */
             /* Updated Typography */
            --font-heading: 'Montserrat', sans-serif;
            --font-body: 'Lato', sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            /* Updated font-family */
            font-family: var(--font-body);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 15px;
            font-size: 16px;
        }

        /* --- Layout & Containers --- */
        #appContainer {
            max-width: 800px; /* Wider container for card layout */
            margin: 20px auto;
            background-color: var(--container-bg);
            padding: 25px; /* Slightly more padding */
            border-radius: 12px; /* Smoother radius */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5); /* Deeper shadow */
        }

        /* Update Headings Font */
        h1, h2, h3, h4 {
            font-family: var(--font-heading);
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 20px;
            font-weight: 600; /* Bolder headings */
        }
        h3 {
             margin-top: 25px;
             margin-bottom: 15px;
             padding-bottom: 8px;
             border-bottom: 1px solid var(--border-color);
             font-weight: 600;
        }
        h4 {
            margin-top: 20px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        h1 {
           margin-bottom: 35px;
           font-size: 2.2em; /* Larger main title */
           font-weight: 700;
        }
        h2 {
            font-size: 1.6em;
        }


        hr {
            border: none;
            height: 1px;
            background-color: var(--border-color);
            margin: 30px 0; /* More spacing */
        }

        /* Hide sections initially */
        #revealMode, #facilitationMode {
            display: none;
        }

         /* --- Forms & Buttons --- */
        input[type="text"] {
            width: calc(100% - 130px); /* Adjust width based on button */
            padding: 12px 15px; /* Slightly larger */
            margin-right: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px; /* Smoother radius */
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1em;
            font-family: var(--font-body); /* Ensure body font */
        }

        input[type="text"]::placeholder {
            color: #8888b0; /* Adjusted placeholder color */
        }

        button {
            padding: 12px 18px; /* Slightly larger */
            background-color: var(--button-bg);
            color: var(--text-color);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            font-family: var(--font-heading); /* Heading font for buttons */
            font-weight: 600;
            transition: background-color 0.2s ease, transform 0.1s ease;
            vertical-align: middle; /* Align button with input */
        }
        button:active:not(:disabled) {
             transform: scale(0.98); /* Click feedback */
        }

        button:hover:not(:disabled) {
            background-color: var(--button-hover-bg);
        }

        button:disabled {
            background-color: var(--button-bg);
            opacity: var(--disabled-opacity);
            cursor: not-allowed;
        }

        #addPlayerContainer {
            display: flex;
            margin-bottom: 25px;
            align-items: center; /* Vertically align items */
        }

        #addPlayerBtn {
             width: 120px; /* Fixed width for add button */
        }

        #assignRolesBtn {
            display: block;
            width: 100%;
            padding: 14px; /* Larger main action button */
            font-size: 1.2em;
            margin-top: 20px;
            background-color: var(--primary-color); /* Accent color for main action */
            color: var(--bg-color); /* Contrast text */
        }
        #assignRolesBtn:hover:not(:disabled) {
            background-color: #d83c54; /* Slightly darker crimson */
        }

        /* --- Lists --- */
        ul {
            list-style: none;
            padding: 0;
            margin-bottom: 15px;
        }

        /* Style for old player list during setup */
        #playerList li {
            background-color: var(--info-bg);
            padding: 12px 18px;
            margin-bottom: 10px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border-color);
            flex-wrap: wrap;
        }
        #playerList li .player-name { /* Ensure class target */
             font-weight: 600;
        }


        /* Common Target List Styling (Night & Day) */
        .target-list li, #dayActionArea ul li {
            background-color: var(--info-bg);
            padding: 12px 18px;
            margin-bottom: 10px;
            border-radius: 6px;
            display: flex;
            justify-content: flex-start; /* Align left */
            align-items: center;
            border: 1px solid var(--border-color);
            flex-wrap: wrap;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease;
        }
        .target-list li:hover, #dayActionArea ul li:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: var(--primary-color);
        }
        .target-list li.selected-target, #dayActionArea ul li.selected-target {
             background-color: var(--selected-bg);
             border-color: var(--primary-color);
             font-weight: bold;
             color: #fff; /* Ensure text visible on selection */
        }
        /* Ensure dead players are not clickable in target lists */
        .target-list li.target-dead, #dayActionArea ul li.target-dead {
            opacity: var(--dead-opacity);
            cursor: not-allowed;
            background-color: rgba(50,50,50,0.1);
            border-color: var(--border-color);
             text-decoration: line-through;
             color: #8888b0;
        }
         .target-list li.target-dead:hover {
             background-color: rgba(50,50,50,0.1); /* Prevent hover effect */
         }


        .remove-player-btn {
            background-color: #a0522d; /* Sienna brown - keep for contrast */
            color: white;
            padding: 6px 10px;
            font-size: 0.9em;
            margin-left: 12px; /* Space from name */
             font-family: var(--font-heading);
             border-radius: 4px;
        }
        .remove-player-btn:hover {
            background-color: #8b4513; /* Saddle brown */
        }

        /* --- Role Selection (NEW CARD LAYOUT) --- */
        #roleSelectionList {
            display: flex;
            flex-wrap: wrap;
            gap: 15px; /* Space between cards */
            margin-top: 15px;
            padding: 10px 0; /* Add some vertical padding */
        }

        .role-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 120px; /* Minimum card width */
            flex-grow: 1; /* Allow cards to grow */
            text-align: center;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .role-card:hover {
             transform: translateY(-3px);
             box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }

        .role-emoji {
            font-size: 2.5em; /* Larger emoji */
            margin-bottom: 8px;
            line-height: 1;
        }

        .role-name {
            font-family: var(--font-heading);
            font-weight: 600;
            font-size: 1em;
            margin-bottom: 12px;
            color: var(--text-color); /* Ensure name is visible */
        }

        .role-quantity {
            display: flex;
            align-items: center;
            margin-top: auto; /* Push quantity controls to bottom */
            padding-top: 10px;
        }

        .role-quantity button {
            width: 30px;
            height: 30px;
            padding: 0;
            font-size: 1.4em;
            line-height: 1; /* Center +/- vertically */
            margin: 0 10px;
            background-color: var(--button-bg);
            color: var(--text-color);
            border-radius: 50%; /* Circular buttons */
        }
         .role-quantity button:hover:not(:disabled) {
             background-color: var(--button-hover-bg);
         }
        .role-quantity button:disabled {
            opacity: 0.4;
        }

        .role-quantity span {
            min-width: 30px; /* Ensure space for number */
            text-align: center;
            font-weight: bold;
            font-size: 1.2em;
            color: var(--primary-color); /* Accent color for count */
        }

        .info-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: var(--info-icon-color); /* Use new info color */
            font-size: 1.3em;
            padding: 2px 5px;
            cursor: pointer;
            line-height: 1;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }
        .info-btn:hover {
            opacity: 1;
        }


        /* --- Validation & Messages --- */
        #playerCountLabel, #totalRolesSelectedLabel {
             font-weight: 600; /* Updated font weight */
             color: var(--primary-color);
             margin-bottom: 15px;
             display: block; /* Ensure labels take full width */
             font-family: var(--font-heading);
             font-size: 1.1em;
        }

        #validationMessage {
            text-align: center;
            margin-top: 20px;
            font-weight: bold;
            min-height: 1.5em; /* Reserve space */
            font-size: 1.1em; /* Slightly larger */
        }

        .invalid {
            color: var(--error-color);
        }
        .valid {
            color: #90ee90; /* Light green - contrast OK */
        }

        /* --- Reveal Mode Specific --- */
        #revealMode {
            text-align: center;
        }
        #revealInstruction {
            font-size: 1.3em; /* Larger instruction */
            margin-bottom: 25px;
            font-family: var(--font-heading);
        }
        #roleDisplay {
            background-color: var(--info-bg);
            padding: 25px;
            border-radius: 8px;
            margin-top: 20px;
            border: 1px solid var(--border-color);
        }
        #revealedRoleName {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        #roleDisplay p {
            margin-bottom: 18px;
            text-align: left;
            font-size: 1.05em;
            line-height: 1.7;
        }
        #freimaurerInfo { /* Looks okay with new theme */
            font-style: italic;
            margin-top: 15px;
            padding: 8px;
            background-color: rgba(0,0,0,0.15);
            border-radius: 5px;
        }
        #toggleLangBtn, #hideRoleBtn {
            margin: 12px 5px 0 5px;
        }
        #revealMode button { /* General reveal buttons */
             margin-top: 20px;
        }
         #revealRoleBtn { /* Specific button */
             padding: 14px 25px;
             font-size: 1.1em;
         }
        #completionMessage {
             font-size: 1.4em;
             color: #90ee90;
             margin-bottom: 25px;
             font-family: var(--font-heading);
        }

        /* --- Facilitation Mode Specific --- */
        #facilitationMode h2 {
            margin-bottom: 20px;
        }

        /* NEW: Lover Display Info */
        #loverDisplay {
            text-align: center;
            margin-bottom: 15px;
            padding: 8px;
            background-color: rgba(233, 69, 96, 0.1); /* Subtle crimson background */
            border: 1px solid var(--primary-color);
            border-radius: 6px;
            font-weight: bold;
            font-size: 1.05em;
        }

        #phaseDisplay {
            font-size: 1.5em; /* Larger */
            font-weight: 700; /* Bolder */
            text-align: center;
            margin-bottom: 30px;
            padding: 12px;
            background-color: var(--info-bg);
            border-radius: 8px;
            font-family: var(--font-heading);
        }

        #dayResultsDisplay {
             background-color: var(--info-bg);
             padding: 15px 20px; /* More padding */
             margin-bottom: 25px;
             border-radius: 8px;
             border: 1px solid var(--border-color);
        }
         #dayResultsDisplay h4 { /* Style heading within results */
             margin-top: 0;
             margin-bottom: 10px;
             padding-bottom: 5px;
             border-bottom: 1px solid var(--border-color);
             text-align: left;
             color: var(--primary-color);
         }
         #dayResultsDisplay p {
             margin: 8px 0;
             font-size: 1.05em;
         }
         /* NEW: GM Note Styling */
         .gm-note {
            font-style: italic;
            color: #aaa; /* Lighter color for GM notes */
            font-size: 0.95em;
            margin-top: 10px;
            padding-top: 5px;
            border-top: 1px dashed rgba(74, 74, 122, 0.5);
         }


        #gmPlayerListContainer {
             margin-top: 20px; /* Add some space above list */
        }

        /* NEW: GM Player Grid Layout */
        #gmPlayerGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); /* Responsive grid */
            gap: 15px;
            margin-top: 15px;
        }

        .gm-player-card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            /* MODIFIED: Added transition for status changes */
            transition: opacity 0.5s ease-in-out, filter 0.5s ease-in-out;
            position: relative; /* For potential absolute elements like mayor icon */
        }

        .gm-player-card .gm-player-emoji {
            font-size: 2em; /* Slightly smaller than role selection */
            margin-bottom: 5px;
            line-height: 1;
        }

        .gm-player-card .gm-player-name {
            font-family: var(--font-heading);
            font-weight: 600;
            font-size: 1.05em;
            margin-bottom: 3px;
            word-break: break-word; /* Prevent long names overflowing */
        }
         .gm-player-card .gm-player-name .mayor-icon {
             margin-left: 4px;
             font-size: 0.9em; /* Adjust crown size */
         }
         /* NEW/MODIFIED: Style for lover icon */
         .gm-player-card .gm-player-name .lover-icon {
             margin-left: 4px;
             /* Optional: Add specific styling like color if needed */
             /* color: var(--primary-color); */
         }


        .gm-player-card .gm-player-role {
            font-size: 0.9em;
            color: #b0b0d0; /* Subdued role color */
            margin-bottom: 8px;
             font-style: italic;
        }

        .gm-player-card .gm-player-status {
             font-weight: bold;
              font-size: 0.95em;
            margin-top: auto; /* Push status to bottom */
            padding-top: 5px;
        }

        /* Status Styling */
        .gm-player-card.status-dead,
        .gm-player-card.status-geist {
            opacity: var(--dead-opacity);
            filter: grayscale(70%); /* Make it grey */
        }

         .gm-player-card .gm-player-status.status-alive {
            color: #90ee90; /* Light Green for Alive */
         }
        .gm-player-card .gm-player-status.status-dead {
            color: #ff8080; /* Light Red for Dead */
        }
        .gm-player-card .gm-player-status.status-geist {
            color: var(--geist-color); /* Greyish for Geist */
            font-style: italic;
        }
        /* End NEW GM Player Grid Layout */


        #phaseControls {
            text-align: center;
            margin-top: 30px;
            margin-bottom: 15px; /* Less margin bottom */
        }
        #phaseControls button {
             margin: 8px;
             min-width: 160px; /* Give buttons consistent width */
             padding: 12px 20px;
        }

        #dayTimerContainer {
            text-align: center;
            margin-top: 25px;
        }
         #dayTimerContainer h3 {
             margin-bottom: 10px;
         }

        #dayTimerDisplay {
            font-size: 3em; /* Larger timer */
            font-weight: 700;
            color: var(--primary-color);
            background-color: var(--info-bg);
            padding: 10px 25px;
            border-radius: 8px;
            display: inline-block; /* Fit content */
            min-width: 140px; /* Ensure space for MM:SS */
            font-family: 'Courier New', Courier, monospace; /* Monospace for timer */
        }

        /* --- General Action Area Styling --- */
         .action-area {
             background-color: var(--info-bg);
             padding: 20px; /* More padding */
             border-radius: 8px;
             margin-top: 25px;
             border: 1px dashed var(--border-color);
             min-height: 180px;
             display: flex;
             flex-direction: column;
         }
         .action-area h4 { /* Action Area Title */
             margin-top: 0;
             margin-bottom: 15px;
             color: var(--primary-color);
             border-bottom: 1px solid var(--border-color);
             padding-bottom: 8px;
             text-align: left;
             font-size: 1.2em;
         }
         .action-area p { /* General text in action area */
            margin-bottom: 15px;
             font-size: 1.05em;
             text-align: left;
         }
         .action-area ul { /* Target list within action areas */
            max-height: 220px; /* Taller list */
            overflow-y: auto;
             border: 1px solid rgba(74, 74, 122, 0.7); /* Adjusted border */
             border-radius: 6px;
             padding: 8px;
             margin-bottom: 20px;
         }
         .action-controls {
             margin-top: auto; /* Push controls to the bottom */
             text-align: center;
             padding-top: 20px;
         }
          .action-controls button {
              margin: 0 8px;
               padding: 10px 15px;
          }


        /* --- Night Action Interface --- */
        #nightActionInterface { /* Uses .action-area styling */
             min-height: 220px;
        }
        #gmPrompt {
             margin-bottom: 20px;
             font-size: 1.15em;
             font-style: italic;
             color: #c0c0e0; /* Slightly adjusted prompt color */
        }
         #gmPrompt p { margin-bottom: 8px; }
         #gmPrompt p:first-child { font-weight: bold; } /* Make primary instruction bold */


        #hexeActionArea {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed rgba(74, 74, 122, 0.7); /* Adjusted border */
        }
        #hexeWolfTargetInfo {
            font-style: italic;
            margin-bottom: 15px;
            color: #ffcc80; /* Light orange - keep for visibility */
            font-size: 1.1em;
            font-weight: bold;
        }
        .hexe-potion-control {
            margin-bottom: 12px;
            display: flex; /* Align items */
            align-items: center;
            gap: 10px;
        }
         .hexe-potion-control > span:first-child { /* Label */
            font-weight: 600;
            min-width: 150px;
         }
        .hexe-potion-control button {
            /* margin-left: 10px; */ /* Replaced by gap */
            min-width: 70px;
            padding: 8px 12px;
            font-size: 0.95em;
        }
        .hexe-potion-control .potion-used {
            color: #aaa;
            font-style: italic;
            font-size: 0.95em;
        }

        #playerSelectionArea {
            /* Combined into .action-area */
        }
        #targetPlayerList { /* Now uses .target-list styling from above */
            /* Inherits styles from .action-area ul and .target-list */
        }

        #seerResultDisplay, #blumenkindResultDisplay { /* NEW: Combined */
            margin-top: 15px;
            font-weight: bold;
            color: #aadeaa; /* Light green for result - contrast OK */
            padding: 8px 12px;
            background-color: rgba(0,0,0,0.25); /* Darker bg */
            border-radius: 5px;
            display: inline-block; /* Keep it tight */
            font-size: 1.1em;
        }

        #nightActionControls { /* Uses .action-controls */
        }


        /* --- Day Action Interface --- */
        #dayActionArea { /* Container for Mayor, Lynch, Jaeger, AKW, Blumenkind */
            /* Uses .action-area styling */
        }
        #dayActionArea ul { /* e.g., mayorCandidateList, lynchCandidateList */
             /* Inherits styles from .action-area ul and .target-list */
        }

         /* --- Game Over Screen --- */
         #gameOverScreen {
             text-align: center;
             padding: 40px; /* More padding */
             background-color: rgba(0,0,0,0.4); /* Darker overlay */
             border-radius: 10px;
             margin-top: 30px;
             border: 1px solid var(--primary-color);
         }
         #gameOverMessage {
             font-size: 1.8em; /* Larger */
             color: var(--primary-color);
             margin-bottom: 25px;
             font-family: var(--font-heading);
             font-weight: 700;
         }
         #restartGameBtn {
             padding: 14px 30px; /* Larger button */
             font-size: 1.2em;
             background-color: var(--primary-color);
             color: var(--bg-color);
         }
          #restartGameBtn:hover {
             background-color: #d83c54;
         }

         /* --- NEW: Role Info Modal --- */
         #roleInfoModal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0, 0, 0, 0.7); /* Black w/ opacity */
            padding-top: 60px; /* Location of the box */
            animation: fadeIn 0.3s ease-out; /* Fade in effect */
         }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #modalContent {
            background-color: var(--container-bg);
            margin: 5% auto; /* 5% from the top and centered */
            padding: 30px;
            border: 1px solid var(--border-color);
            width: 80%; /* Could be more or less, depending on screen size */
            max-width: 500px; /* Maximum width */
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.4);
            position: relative;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
             from { transform: translateY(-20px); opacity: 0;}
             to { transform: translateY(0); opacity: 1;}
        }


        #modalCloseBtn {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
        }

        #modalCloseBtn:hover,
        #modalCloseBtn:focus {
            color: var(--text-color);
            text-decoration: none;
            cursor: pointer;
        }

        #modalRoleName {
             font-family: var(--font-heading);
             color: var(--primary-color);
             font-size: 1.6em;
             margin-bottom: 15px;
             text-align: center;
             font-weight: 700;
        }

        #modalRoleDescDe, #modalRoleDescEn {
             font-family: var(--font-body);
             font-size: 1.05em;
             line-height: 1.7;
             margin-bottom: 10px;
             color: var(--text-color);
        }
        #modalRoleDescEn { display: none; } /* Hide EN initially in modal */

         #modalLangToggle { /* Button to toggle lang inside modal */
             display: block;
             margin: 15px auto 5px auto; /* Center button */
             padding: 8px 12px;
             font-size: 0.9em;
         }


        /* --- Responsiveness --- */
        @media (max-width: 768px) { /* Tablet breakpoint */
             #appContainer { max-width: 95%; padding: 20px; }
             .role-card { min-width: 100px; padding: 12px; } /* Smaller cards */
             .role-emoji { font-size: 2em; }
             h1 { font-size: 1.9em; }
             h2 { font-size: 1.5em; }
             #dayTimerDisplay { font-size: 2.5em; }
             #phaseControls button { min-width: 140px; margin: 5px;}
             .action-area ul { max-height: 180px; }
             #gmPlayerGrid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 10px;} /* Adjust grid for tablets */
             .gm-player-card { padding: 10px; }
             .gm-player-card .gm-player-emoji { font-size: 1.8em; }
             .gm-player-card .gm-player-name { font-size: 1em; }
             .gm-player-card .gm-player-role { font-size: 0.85em; }
             .gm-player-card .gm-player-status { font-size: 0.9em; }
        }


        @media (max-width: 480px) { /* Mobile breakpoint */
            body { padding: 10px; font-size: 15px; }
            #appContainer { padding: 15px; border-radius: 8px; }
            h1 { font-size: 1.7em; margin-bottom: 25px;}
            h2 { font-size: 1.3em; }
            h3 { font-size: 1.1em; margin-top: 20px; margin-bottom: 10px; }
            h4 { font-size: 1.0em; margin-top: 15px; margin-bottom: 8px;}

            input[type="text"] { width: calc(100% - 110px); font-size: 0.95em; padding: 10px 12px;}
            #addPlayerBtn { width: 100px; font-size: 0.95em; padding: 10px 10px; }
            button { padding: 10px 15px; font-size: 0.95em; border-radius: 5px;} /* General buttons */
            #assignRolesBtn { padding: 12px; font-size: 1.1em;}

            /* Role cards on mobile */
             #roleSelectionList { gap: 10px; }
             .role-card {
                 min-width: calc(50% - 10px); /* Approx 2 cards per row */
                 padding: 10px;
                 border-radius: 6px;
             }
             .role-emoji { font-size: 1.8em; }
             .role-name { font-size: 0.9em; margin-bottom: 8px; }
             .role-quantity button { width: 26px; height: 26px; font-size: 1.2em; margin: 0 8px;}
             .role-quantity span { font-size: 1.1em; min-width: 25px; }
             .info-btn { font-size: 1.1em; top: 5px; right: 5px; }

            /* OLD GM List items - remove or adjust if needed */
            /* #playerList li, #gmPlayerList li, ... */

            #phaseDisplay { font-size: 1.3em; }
            #dayTimerDisplay { font-size: 2.2em; min-width: 120px; }
            #phaseControls button { min-width: 120px; font-size: 0.9em; padding: 10px 15px;}

             /* NEW GM Grid on Mobile */
            #gmPlayerGrid { grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px;} /* Smaller cards on mobile */
             .gm-player-card { padding: 8px; }
             .gm-player-card .gm-player-emoji { font-size: 1.6em; }
             .gm-player-card .gm-player-name { font-size: 0.9em; }
             .gm-player-card .gm-player-role { font-size: 0.8em; margin-bottom: 5px;}
             .gm-player-card .gm-player-status { font-size: 0.85em; }

             #gmPrompt { font-size: 1.05em;}
             .action-area { padding: 15px; min-height: 150px;}
             .action-area ul { max-height: 150px; } /* Shorter lists on mobile */
             .action-controls button { font-size: 0.9em; padding: 8px 12px;}
             #gameOverMessage { font-size: 1.4em; }
              #restartGameBtn { padding: 12px 25px; font-size: 1.1em;}

              /* Modal on mobile */
              #modalContent { width: 90%; padding: 20px; }
              #modalRoleName { font-size: 1.4em;}
              #modalRoleDescDe, #modalRoleDescEn { font-size: 1em; }
             #loverDisplay { font-size: 0.95em; } /* Adjust lover display size */
        }

        /* --- NEW: On-Page Console Styles --- */
        #consoleToggleContainer {
            text-align: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px dashed var(--border-color);
        }

        #toggleConsoleBtn {
            background-color: var(--button-bg);
            font-size: 0.9em;
        }
        #toggleConsoleBtn:hover {
            background-color: var(--button-hover-bg);
        }
        #toggleConsoleBtn.active { /* Style when console is visible */
            background-color: var(--primary-color);
            color: var(--bg-color);
        }


        #onPageConsole {
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-top: 15px;
            padding: 10px 15px;
            max-height: 200px; /* Limit height */
            overflow-y: auto; /* Add scroll */
            font-size: 0.85em;
        }

        #onPageConsole h4 {
            margin-top: 0;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
            color: var(--primary-color);
            text-align: left;
            font-size: 1.1em; /* Adjusted from parent */
        }

        #consoleOutput {
            white-space: pre-wrap; /* Wrap long lines */
            word-wrap: break-word; /* Break words if necessary */
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.4;
        }

        #consoleOutput .log-warn {
            color: #ffcc80; /* Light orange */
        }

        #consoleOutput .log-error {
            color: var(--error-color); /* Use theme error color */
            font-weight: bold;
        }
        /* --- End On-Page Console Styles --- */

        /* --- Responsiveness (Add console hiding) --- */
        @media (max-width: 768px) { /* Tablet breakpoint */
             /* ... existing styles ... */
             #onPageConsole { max-height: 150px; font-size: 0.8em; }
        }


        @media (max-width: 480px) { /* Mobile breakpoint */
            /* ... existing styles ... */
             #onPageConsole { max-height: 120px; font-size: 0.75em; padding: 8px 10px;}
             #loverDisplay { font-size: 0.95em; } /* Adjust lover display size */
        }

        .gm-player-card.is-lover {
            border: 2px solid var(--primary-color); /* Crimson border */
            box-shadow: 0 0 10px rgba(233, 69, 96, 0.5); /* Optional: Add a glow */
        }

        .gm-player-card .gm-player-name {
            font-family: var(--font-heading);
            font-weight: 600;
            font-size: 1.05em;
            margin-bottom: 3px;
            word-break: break-word; /* Prevent long names overflowing */
            display: flex; /* Use flexbox to align items */
            align-items: center; /* Vertically center items */
            justify-content: center; /* Horizontally center items */
            gap: 4px; /* Add space between elements */
        }
         .gm-player-card .gm-player-name .mayor-icon {
            /* margin-left: 4px; */ /* Replaced by gap */
            font-size: 0.9em; /* Adjust crown size */
            order: 1; /* Ensure icons come after name if needed */
         }
         /* NEW/MODIFIED: Style for lover icon */
         .gm-player-card .gm-player-name .lover-icon {
             /* margin-left: 4px; */ /* Replaced by gap */
             /* Optional: Add specific styling like color if needed */
             /* color: var(--primary-color); */
              order: 2; /* Ensure icons come after name */
         }

    </style>
</head>
<body>

    <div id="appContainer">
        <h1>Werwolf Manager</h1>

        <div id="setupMode">
            <div id="playerSetup">
                <h2>Spieler verwalten</h2>
                <div id="addPlayerContainer">
                    <input type="text" id="playerNameInput" placeholder="Spielername eingeben...">
                    <button id="addPlayerBtn">Hinzufügen</button>
                </div>
                 <p id="playerCountLabel">Aktuelle Spieler (<span id="playerCount">0</span>):</p>
                <ul id="playerList"></ul>
            </div>
            <hr>
            <div id="roleSetup">
                <h2>Rollen auswählen</h2>
                 <p id="totalRolesSelectedLabel">Ausgewählte Rollen insgesamt: <span id="totalRolesSelected">0</span></p>
                 <!-- Role cards will be rendered here -->
                <div id="roleSelectionList"></div>
            </div>
            <hr>
            <div id="validationSection">
                <p id="validationMessage"></p>
                <button id="assignRolesBtn" disabled>Rollen Zuweisen & Aufdecken starten</button>
            </div>
        </div>

        <!-- Reveal Mode (largely unchanged structure, benefits from new theme) -->
        <div id="revealMode">
            <p id="revealInstruction"></p>
            <button id="revealRoleBtn">Meine Rolle aufdecken</button>
            <div id="roleDisplay" style="display: none;">
                <h3 id="revealedRoleName"></h3>
                <p id="revealedRoleDescDe"></p>
                <button id="toggleLangBtn">Auf Englisch anzeigen</button>
                <p id="revealedRoleDescEn" style="display: none;"></p>
                <button id="hideRoleBtn">Rolle verstanden & verbergen</button>
            </div>
             <div id="completionScreen" style="display: none;">
                 <p id="completionMessage">Setup abgeschlossen!</p>
                 <button id="switchToFacilitationBtn">Zur Spielleitung wechseln</button>
            </div>
        </div>

         <!-- Facilitation Mode (largely unchanged structure, benefits from new theme) -->
        <div id="facilitationMode">
             <!-- ... existing facilitation mode content ... -->
              <h2>Spielleitungs-Modus</h2>

             <div id="phaseDisplay">Spiel noch nicht gestartet</div>

             <div id="dayResultsDisplay" style="display: none;">
                 <!-- Populated by JS -->
             </div>

             <!-- NEW: Lover Display -->
             <div id="loverDisplay" style="display: none;"></div>

             <div id="gmPlayerListContainer">
                  <h3>Spielerübersicht</h3> <!-- Simplified Title -->
                  <!-- REPLACED UL with DIV -->
                  <div id="gmPlayerGrid">
                      <!-- Populated by JS -->
                  </div>
             </div>

             <div id="dayTimerContainer" style="display: none;">
                 <h3>Tag Phase Timer</h3>
                 <div id="dayTimerDisplay">00:00</div>
             </div>

             <!-- Consolidated Day Action Area -->
             <div id="dayActionArea" class="action-area" style="display: none;">
                 <h4 id="dayActionTitle">Tagesaktion</h4>
                 <p id="dayActionPrompt"></p>

                 <!-- Content will be dynamically populated based on gamePhaseState -->
                 <ul id="dayActionTargetList" class="target-list"></ul>

                 <!-- Specific controls shown/hidden by JS -->
                 <div class="action-controls" id="dayActionControls">
                     <button id="dayActionConfirmBtn" disabled>Bestätigen</button>
                     <button id="dayActionSkipBtn" style="display: none;">Überspringen / Abbrechen</button>
                 </div>

                  <!-- For Reinigungskraft -->
                  <div id="reinigungskraftChoiceArea" style="display: none;">
                      <p>Reinigungskraft: Rolle des Gelynchten verbergen?</p>
                      <button data-choice="yes">Ja</button>
                      <button data-choice="no">Nein</button>
                  </div>

                  <!-- For Blumenkind -->
                  <div id="blumenkindSaveArea" style="display: none;">
                       <p>Blumenkind: Spieler vor Lynchung retten?</p>
                       <button data-choice="yes">Ja</button>
                       <button data-choice="no">Nein</button>
                  </div>
             </div>


             <div id="nightActionInterface" class="action-area" style="display: none;">
                  <div id="gmPrompt"></div>

                  <div id="hexeActionArea" style="display: none;">
                      <p id="hexeWolfTargetInfo"></p>
                      <div class="hexe-potion-control" id="hexeHealControl">
                          <span>Heiltrank verfügbar:</span>
                          <button data-potion="heal" data-action="yes">Ja</button>
                          <button data-potion="heal" data-action="no">Nein</button>
                          <span class="potion-used" style="display: none;">Heiltrank eingesetzt.</span>
                      </div>
                      <div class="hexe-potion-control" id="hexePoisonControl">
                           <span>Gifttrank verfügbar:</span>
                           <button data-potion="poison" data-action="yes">Ja</button>
                           <button data-potion="poison" data-action="no">Nein</button>
                          <span class="potion-used" style="display: none;">Gifttrank eingesetzt.</span>
                      </div>
                  </div>

                  <div id="playerSelectionArea" style="display: none;"> <!-- Still used within night interface -->
                      <h4 id="selectionTitle"></h4>
                      <ul id="targetPlayerList" class="target-list">
                          </ul>
                      <p id="seerResultDisplay" style="display: none;"></p>
                      <p id="blumenkindResultDisplay" style="display: none;"></p> <!-- For first night -->
                  </div>
                  <div class="action-controls" id="nightActionControls">
                      <button id="nightActionNextBtn">Weiter</button>
                      <button id="nightActionConfirmBtn" style="display: none;">Bestätigen</button>
                      <button id="nightActionSkipBtn" style="display: none;">Überspringen / Fertig</button>
                  </div>
              </div>

              <!-- Game Over Screen -->
              <div id="gameOverScreen" style="display: none;">
                  <h3 id="gameOverMessage"></h3>
                  <button id="restartGameBtn">Neues Spiel starten</button>
              </div>

              <div id="phaseControls">
                  <button id="startNightBtn">Nacht 1 starten</button>
                  <button id="startDayBtn" style="display: none;">Tag starten</button>
                  <button id="startVoteBtn" style="display: none;">Abstimmung starten</button>
                  <button id="startNextNightBtn" style="display: none;">Nächste Nacht starten</button>
              </div>
        </div>

        <!-- NEW: Role Info Modal Structure -->
        <div id="roleInfoModal">
            <div id="modalContent">
                <button id="modalCloseBtn">&times;</button>
                <h3 id="modalRoleName"></h3>
                <p id="modalRoleDescDe"></p>
                <p id="modalRoleDescEn"></p>
                <button id="modalLangToggle">Show in English</button>
            </div>
        </div>

        <!-- NEW: On-Page Console -->
        <div id="consoleToggleContainer">
            <button id="toggleConsoleBtn">Konsole anzeigen</button>
        </div>
        <div id="onPageConsole" style="display: none;">
            <h4>Konsole</h4>
            <pre id="consoleOutput"></pre>
        </div>

    </div> <!-- End of appContainer -->

    <script>
        // --- State Variables ---
        // ... (existing state variables) ...
        let players = []; // Setup phase: ['name1', 'name2']
        let initialPlayerOrder = []; // Preserves original entry order
        let roles = {}; // Setup phase: { roleId: count }
        let assignedRoles = []; // Reveal phase: [{ player: 'name', roleData: {...} }]
        let currentPlayerIndex = 0; // Reveal phase index
        let isConsoleVisible = false; // NEW: State for on-page console
        const MAX_CONSOLE_LINES = 200; // NEW: Limit console lines

        let gameState = {
             players: [], // Main game state: [{ name: '...', roleData: {...}, status: 'Lebend'/'Tot'/'Geist', isBuergermeister: false, isProtected: false, isBitten: false, visitedPlayer: null, originalRoleData: null (for Geist) }]
             currentPhase: null, // 'Nacht', 'Tag', 'SETUP', 'REVEAL', 'GAME_OVER'
             gamePhaseState: null, // Detailed state: 'SETUP', 'REVEAL', 'NIGHT_ACTION', 'NIGHT_RESULTS', 'DAY_DISCUSSION', 'DAY_MAYOR_VOTE', 'DAY_BLUMENKIND_SAVE', 'DAY_LYNCH_VOTE', 'DAY_LYNCH_CONFIRM', 'DAY_REINIGUNGSKRAFT', 'JAEGER_SHOT', 'AKW_SELECTION', 'GAME_OVER'
             phaseNumber: 0,
             dayTimerInterval: null,
             dayTimerSeconds: 0,
             nightActionSequence: [], // Dynamically built
             currentNightActionStep: -1,
             nightSelections: { // Reset each night
                 werwolfTarget: null,
                 seherinCheck: null,
                 protectedThisNight: null, // Leibwächter/Priester target
                 healPotionUsedOn: null, // Hexe heal target
                 poisonPotionTarget: null, // Hexe poison target
                 amorPair: [], // Set only Night 1
                 dorfmatratzeVisit: null,
                 vampirTarget: null,
             },
             nightResults: { // Calculated at start of Day
                 killedPlayerName: null, killedPlayerRole: null, // Werwolf kill
                 poisonedPlayerName: null, poisonedPlayerRole: null, // Hexe kill
                 bittenPlayerName: null, bittenPlayerRole: null, // Vampir bite (doesn't die immediately)
                 holyWaterKillName: null, holyWaterKillRole: null, // Priester alternative (not used in protective)
                 dorfmatratzeDeath: [], // [matratzeName, visitedName] if both die
                 savedByBodyguard: null,
                 savedByPriest: null, // Add if Priest protects
                 savedByHexe: null,
                 savedByMatratze: null, // Matratze survives if attacked at home
                 turnedVerfluchter: null, // Name of player turned
             },
             dailyDeaths: [], // Stores deaths occurring during the day { name: '...', role: '...', cause: '...' } - Reset each day
             buergermeister: null, // Name of the Mayor
             hexeHasHealPotion: true,
             hexeHasPoisonPotion: true,
             bodyguardLastProtected: null,
             loverPair: [], // [name1, name2] - Set by Amor Night 1
             pendingHunterShot: false,
             hunterVictim: null,
             hunterTarget: null, // Who the hunter shot
             pendingAkwSelection: false,
             akwVictim: null,
             akwSelectedNeighbors: [], // Neighbors killed by AKW
             lynchTarget: null,
             lynchVictimRole: null,
             diedWithLover: null, // Name of lover who died from heartbreak
             diedFromHunter: null, // Name of player shot by hunter
             diedFromAKW: [], // List of player names killed by AKW this phase
             diedFromVampireBite: null, // Name of player dying from previous night's bite
             diedFromDorfmatratze: [], // Names of matratze/visited killed this phase
             blumenkindUsedSave: false, // Has Blumenkind used their save?
             blumenkindSavedPlayer: null, // Player saved by Blumenkind this day
             reinigungskraftUsedClean: false, // Has Reinigungskraft used their ability?
             hideLynchRole: false, // Set by Reinigungskraft
             // Guenstling Faction? Store here if needed
             gameOver: false,
             winner: null, // 'Dorf', 'Werwolf', 'Liebende', 'Vampir', 'Niemand'
             // No explicit need for akwPendingBiteDeath array, isBitten flag is sufficient
        };

        // Role Definitions - Faction property is crucial
        const availableRoles = [
             // Added emoji property
             { id: 'werwolf', name: 'Werwolf', emoji: '🐺', faction: 'Werwolf', descDE: 'Du erwachst in der Nacht mit den anderen Werwölfen und ihr wählt gemeinsam ein Opfer.', descEN: 'You wake up at night with the other werewolves and together you choose a victim.' },
             { id: 'dorfbewohner', name: 'Dorfbewohner', emoji: '🧑‍🌾', faction: 'Dorf', descDE: 'Du hast keine besonderen Fähigkeiten. Finde die Werwölfe und überlebe!', descEN: 'You have no special abilities. Find the werewolves and survive!' },
             { id: 'amor', name: 'Amor', emoji: '💘', faction: 'Dorf', // Win condition can change
                 descDE: 'Nur in der ersten Nacht: Du wählst zwei Spieler (oder dich selbst und einen anderen), die sich unsterblich verlieben. Stirbt einer, stirbt der andere sofort aus Kummer. Die Liebenden gewinnen nur, wenn sie als einzige überleben.',
                 descEN: 'First night only: You choose two players (or yourself and another) who fall madly in love. If one dies, the other dies immediately of heartbreak. The lovers only win if they are the last two survivors.' },
             { id: 'hexe', name: 'Hexe', emoji: '🧙‍♀️', faction: 'Dorf',
                 descDE: 'Du erwachst einmal pro Nacht nach den Werwölfen. Du siehst, wen sie gewählt haben. Du kannst einmal im Spiel einen Heiltrank (Opfer retten) und einmal einen Gifttrank (beliebigen Spieler töten) einsetzen.',
                 descEN: 'You wake up once per night after the werewolves. You see who they targeted. You can use a healing potion once (save victim) and a poison potion once (kill any player) during the game.' },
             { id: 'seherin', name: 'Seherin', emoji: '👁️', faction: 'Dorf',
                 descDE: 'Du erwachst jede Nacht und darfst auf die Rolle eines Mitspielers schauen (Werwolf Ja/Nein).',
                 descEN: 'You wake up each night and get to look at the role of one player (Werewolf Yes/No).' },
             { id: 'jaeger', name: 'Jäger', emoji: '🎯', faction: 'Dorf',
                 descDE: 'Wenn du stirbst (egal wie), darfst du einen letzten Schuss abgeben und einen Spieler deiner Wahl mit in den Tod reißen.',
                 descEN: 'If you die (no matter how), you get to fire one last shot, taking a player of your choice with you into death.' },
             { id: 'leibwaechter', name: 'Leibwächter', emoji: '🛡️', faction: 'Dorf',
                 descDE: 'Du erwachst jede Nacht und wählst einen Spieler, den du beschützen möchtest (nicht dich selbst). Der Spieler überlebt den Werwolf-Angriff (oder Vampirbiss). Du kannst nicht zweimal hintereinander dieselbe Person schützen.',
                 descEN: 'You wake up each night and choose a player you want to protect (not yourself). That player survives the werewolf attack (or vampire bite). You cannot protect the same person twice in a row.' },
             { id: 'verfluchter', name: 'Verfluchter', emoji: '⛓️', faction: 'Dorf', // Faction changes
                 descDE: 'Du startest als Dorfbewohner. Wirst du von den Werwölfen angegriffen, stirbst du nicht, sondern wirst selbst zum Werwolf (ab der nächsten Nacht). Die Seherin sieht dich bis dahin als Dorfbewohner. Stirbst du anders, stirbst du als Dorfbewohner.',
                 descEN: 'You start as a villager. If targeted by werewolves, you don\'t die but become a werewolf instead (starting next night). The Seer sees you as a villager until then. If you die any other way, you die as a villager.' },
             { id: 'priester', name: 'Priester', emoji: '🙏', faction: 'Dorf', // Protective Version
                 descDE: 'Du erwachst jede Nacht und wählst einen Spieler. Dieser Spieler ist vor dem ersten Angriff durch Werwölfe oder Vampire in dieser Nacht geschützt.',
                 descEN: 'You wake up each night and choose one player. This player is protected from the first attack by Werewolves or Vampires this night.' },
             { id: 'dorfmatratze', name: 'Dorfmatratze', emoji: '💃', faction: 'Dorf',
                 descDE: 'Du erwachst jede Nacht und wählst einen Spieler, den du besuchst. Wirst du zu Hause angegriffen, überlebst du. Wird dein besuchter Spieler angegriffen, sterbt ihr beide.',
                 descEN: 'You wake up each night and choose a player to visit. If you are attacked at home, you survive. If the player you visit is attacked, you both die.' },
             { id: 'blumenkind', name: 'Blumenkind', emoji: '🌸', faction: 'Dorf', // NEW DEFINITION
                 descDE: 'Du bist ein Dorfbewohner, der einmal im Spiel einen Spieler direkt vor der Lynch-Abstimmung retten kann.',
                 descEN: 'You are a villager who can save one player from the lynching vote once per game.' },
             { id: 'akw', name: 'AKW', emoji: '☢️', faction: 'Dorf',
                 descDE: 'Du bist ein Dorfbewohner. Wenn du stirbst (egal wie), wählt der Spielleiter sofort bis zu zwei lebende Spieler aus, die ebenfalls sterben (GM entscheidet). Stirbst du durch Vampirbiss, tritt dieser Effekt erst am Ende des nächsten Tages ein.',
                 descEN: 'You are a villager. If you die (no matter how), the Game Master immediately selects up to two living players who also die (GM decides). If you die from a vampire bite, this effect occurs at the end of the next day.' },
             { id: 'vampir', name: 'Vampir', emoji: '🧛', faction: 'Vampir',
                 descDE: 'Eigene Fraktion, Ziel: alle anderen eliminieren. Erwacht jede Nacht, beißt ein Opfer. Opfer stirbt am Ende des nächsten Tages (nach der Lynchung). Immun gegen Werwolf-Angriffe.',
                 descEN: 'Separate faction, goal: eliminate all others. Wake up each night, bite a victim. Victim dies at the end of the next day (after the lynching). Immune to Werewolf attacks.' },
             { id: 'guenstling', name: 'Günstling', emoji: '🤫', faction: 'Dorf', // Faction can be reassigned
                 descDE: 'Du bist ein Dorfbewohner, hilfst aber heimlich einer bösen Fraktion (Werwölfe oder Vampire, vom GM festgelegt). Du gewinnst mit dieser Fraktion. Die Seherin sieht dich nicht als Werwolf.',
                 descEN: 'You are a villager, but secretly help an evil faction (Werewolves or Vampires, decided by GM). You win with that faction. The Seer does not see you as a Werewolf.' },
             { id: 'reinigungskraft', name: 'Reinigungskraft', emoji: '🧹', faction: 'Dorf',
                 descDE: 'Einmal pro Spiel, nach einer Lynchung: Du kannst erwachen und entscheiden, ob die Rolle des Gelynchten öffentlich bekannt gegeben wird oder nicht.',
                 descEN: 'Once per game, after a lynching: You can wake up and decide whether the role of the lynched player is revealed publicly or not.' },
             { id: 'geist', name: 'Geist', emoji: '👻', faction: 'Neutral', // Usually considered neutral once dead
                 descDE: 'Wenn du stirbst, wirst du zum Geist. Du kannst nicht mehr sprechen oder abstimmen. Der Spielleiter sieht deine ursprüngliche Rolle.',
                 descEN: 'When you die, you become a Ghost. You can no longer speak or vote. The Game Master sees your original role.' },
             { id: 'freimaurer', name: 'Freimaurer', emoji: '🤝', faction: 'Dorf',
                 descDE: 'Du bist ein Dorfbewohner. In der ersten Nacht erfährst du, wer der/die andere(n) Freimaurer ist/sind. Ihr habt keine weiteren Fähigkeiten.',
                 descEN: 'You are a villager. On the first night, you learn who the other Freemason(s) is/are. You have no other abilities.' }
        ];


        // --- DOM Elements (Setup & Reveal) ---
        const playerNameInput = document.getElementById('playerNameInput');
        const addPlayerBtn = document.getElementById('addPlayerBtn');
        const playerListUl = document.getElementById('playerList');
        const playerCountSpan = document.getElementById('playerCount');
        // Updated: Target the DIV container for role cards
        const roleSelectionListDiv = document.getElementById('roleSelectionList');
        const totalRolesSelectedSpan = document.getElementById('totalRolesSelected');
        const validationMessageP = document.getElementById('validationMessage');
        const assignRolesBtn = document.getElementById('assignRolesBtn');
        const setupModeDiv = document.getElementById('setupMode');
        const revealModeDiv = document.getElementById('revealMode');
        const revealInstructionP = document.getElementById('revealInstruction');
        const revealRoleBtn = document.getElementById('revealRoleBtn');
        const roleDisplayDiv = document.getElementById('roleDisplay');
        const revealedRoleNameH3 = document.getElementById('revealedRoleName');
        const revealedRoleDescDeP = document.getElementById('revealedRoleDescDe');
        const toggleLangBtn = document.getElementById('toggleLangBtn');
        const revealedRoleDescEnP = document.getElementById('revealedRoleDescEn');
        const hideRoleBtn = document.getElementById('hideRoleBtn');
        const completionScreenDiv = document.getElementById('completionScreen');
        const switchToFacilitationBtn = document.getElementById('switchToFacilitationBtn');

         // --- DOM Elements (Facilitation) ---
        const facilitationModeDiv = document.getElementById('facilitationMode');
        const phaseDisplayDiv = document.getElementById('phaseDisplay');
        const dayResultsDisplayDiv = document.getElementById('dayResultsDisplay');
        const gmPlayerListContainer = document.getElementById('gmPlayerListContainer');
        const gmPlayerGridDiv = document.getElementById('gmPlayerGrid'); // UPDATED: Target the grid div
        const dayTimerContainerDiv = document.getElementById('dayTimerContainer');
        const dayTimerDisplayDiv = document.getElementById('dayTimerDisplay');
        const phaseControlsDiv = document.getElementById('phaseControls');
        const startNightBtn = document.getElementById('startNightBtn');
        const startDayBtn = document.getElementById('startDayBtn');
        const startNextNightBtn = document.getElementById('startNextNightBtn');
        const startVoteBtn = document.getElementById('startVoteBtn');
        const dayActionAreaDiv = document.getElementById('dayActionArea'); // Consolidated Day Action Area
        const dayActionTitleH4 = document.getElementById('dayActionTitle');
        const dayActionPromptP = document.getElementById('dayActionPrompt');
        const dayActionTargetListUl = document.getElementById('dayActionTargetList');
        const dayActionControlsDiv = document.getElementById('dayActionControls');
        const dayActionConfirmBtn = document.getElementById('dayActionConfirmBtn');
        const dayActionSkipBtn = document.getElementById('dayActionSkipBtn');
        const reinigungskraftChoiceAreaDiv = document.getElementById('reinigungskraftChoiceArea');
        const blumenkindSaveAreaDiv = document.getElementById('blumenkindSaveArea');
        const gameOverScreenDiv = document.getElementById('gameOverScreen');
        const gameOverMessageH3 = document.getElementById('gameOverMessage');
        const restartGameBtn = document.getElementById('restartGameBtn');
        const loverDisplayDiv = document.getElementById('loverDisplay'); // NEW: Lover display div


         // --- DOM Elements (Night Action Interface) ---
        const nightActionInterfaceDiv = document.getElementById('nightActionInterface');
        const gmPromptDiv = document.getElementById('gmPrompt');
        const playerSelectionAreaDiv = document.getElementById('playerSelectionArea');
        const selectionTitleH4 = document.getElementById('selectionTitle');
        const targetPlayerListUl = document.getElementById('targetPlayerList');
        const seerResultDisplayP = document.getElementById('seerResultDisplay');
        const blumenkindResultDisplayP = document.getElementById('blumenkindResultDisplay'); // For 1st night Blumenkind (if using that version)
        const nightActionControlsDiv = document.getElementById('nightActionControls');
        const nightActionNextBtn = document.getElementById('nightActionNextBtn');
        const nightActionConfirmBtn = document.getElementById('nightActionConfirmBtn');
        const nightActionSkipBtn = document.getElementById('nightActionSkipBtn');
        const hexeActionAreaDiv = document.getElementById('hexeActionArea');
        const hexeWolfTargetInfoP = document.getElementById('hexeWolfTargetInfo');
        const hexeHealControlDiv = document.getElementById('hexeHealControl');
        const hexePoisonControlDiv = document.getElementById('hexePoisonControl');

        // --- DOM Elements (Role Info Modal) ---
        const roleInfoModal = document.getElementById('roleInfoModal');
        const modalContent = document.getElementById('modalContent');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalRoleName = document.getElementById('modalRoleName');
        const modalRoleDescDe = document.getElementById('modalRoleDescDe');
        const modalRoleDescEn = document.getElementById('modalRoleDescEn');
        const modalLangToggle = document.getElementById('modalLangToggle');

        // --- NEW: DOM Elements (On-Page Console) ---
        const toggleConsoleBtn = document.getElementById('toggleConsoleBtn');
        const onPageConsoleDiv = document.getElementById('onPageConsole');
        const consoleOutputPre = document.getElementById('consoleOutput');


        // --- Utility Functions ---
        // ... (existing utility functions: escapeHTML, shuffleArray, getPlayerData, etc.) ...
        function escapeHTML(str) {
            if (typeof str !== 'string') return '';
            const div = document.createElement('div');
            div.appendChild(document.createTextNode(str));
            return div.innerHTML;
         }

         function shuffleArray(array) {
             let currentIndex = array.length, randomIndex;
             while (currentIndex !== 0) {
                 randomIndex = Math.floor(Math.random() * currentIndex);
                 currentIndex--;
                 [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
             }
             return array;
         }

         function getPlayerData(playerName) {
            return gameState.players.find(p => p.name === playerName);
         }

        function getLivingPlayers() {
            return gameState.players.filter(p => p.status === 'Lebend');
        }

        function getLivingPlayersWithoutRole(roleId) {
            return getLivingPlayers().filter(p => p.roleData.id !== roleId);
        }

        function isRoleActive(roleId) {
            return gameState.players.some(p => p.roleData.id === roleId && p.status === 'Lebend');
        }

        // Helper to check if the results div has meaningful content beyond just the header
        function hasResultsContent(div) {
            if (!div) return false;
            const headerText = '<h4>Ergebnisse der Nacht</h4>';
            // Check if innerHTML is different from the basic header or empty
            return div.innerHTML.trim() !== '' && div.innerHTML.trim() !== headerText;
        }

        function switchView(viewToShow) {
            console.log("Switching view to:", viewToShow);
            setupModeDiv.style.display = 'none';
            revealModeDiv.style.display = 'none';
            facilitationModeDiv.style.display = 'none';
            roleInfoModal.style.display = 'none'; // Ensure modal is hidden on view switch

            if (viewToShow === 'setup') {
                 setupModeDiv.style.display = 'block';
                 // Reset setup state if returning
                 players = [];
                 initialPlayerOrder = [];
                 roles = {};
                 assignedRoles = [];
                 renderPlayerList();
                 renderRoleSelection(); // Render new cards
                 updateValidation();
            } else if (viewToShow === 'reveal') {
                 revealModeDiv.style.display = 'block';
                 completionScreenDiv.style.display = 'none';
                 revealInstructionP.style.display = 'block';
                 revealRoleBtn.style.display = 'inline-block';
                 roleDisplayDiv.style.display = 'none';
            } else if (viewToShow === 'facilitation') {
                facilitationModeDiv.style.display = 'block';
                // Ensure game over screen is hidden on switch
                gameOverScreenDiv.style.display = 'none';
            } else if (viewToShow === 'completion') { // End of reveal phase
                 revealModeDiv.style.display = 'block';
                 revealInstructionP.style.display = 'none';
                 revealRoleBtn.style.display = 'none';
                 roleDisplayDiv.style.display = 'none';
                 completionScreenDiv.style.display = 'block';
            }
        }

        // --- Setup & Reveal Mode Functions ---
        function renderPlayerList() {
             playerListUl.innerHTML = '';
            players.forEach((player, index) => {
                const li = document.createElement('li');
                li.innerHTML = `
                    <span class="player-name">${escapeHTML(player)}</span>
                    <button class="remove-player-btn" data-index="${index}">Entfernen</button>
                `;
                playerListUl.appendChild(li);
            });
            playerCountSpan.textContent = players.length;
            updateValidation();
        }

        function addPlayer() {
            const playerName = playerNameInput.value.trim();
            if (playerName && !players.includes(playerName)) {
                players.push(playerName);
                initialPlayerOrder.push(playerName); // Store initial order
                playerNameInput.value = '';
                renderPlayerList();
            } else if (players.includes(playerName)) {
                 // Consider a less intrusive notification (e.g., message below input)
                 alert(`Spieler "${escapeHTML(playerName)}" ist bereits in der Liste.`);
            }
            playerNameInput.focus();
        }

        function removePlayer(index) {
            if (index >= 0 && index < players.length) {
                const removedPlayerName = players[index];
                players.splice(index, 1);
                // Also remove from initial order tracking
                const initialIndex = initialPlayerOrder.indexOf(removedPlayerName);
                if (initialIndex > -1) {
                    initialPlayerOrder.splice(initialIndex, 1);
                }
                renderPlayerList();
            }
        }

        // --- UPDATED Role Selection Rendering ---
        function renderRoleSelection() {
            roleSelectionListDiv.innerHTML = ''; // Target the DIV now
            let totalRoles = 0;
            availableRoles.forEach(role => {
                if (!role || !role.id || !role.name) {
                     console.error("Skipping invalid role definition:", role);
                     return; // Skip this iteration
                 }
                const currentCount = roles[role.id] || 0;
                totalRoles += currentCount;
                const card = document.createElement('div');
                card.className = 'role-card';
                card.innerHTML = `
                    <button class="info-btn" data-role-id="${role.id}" title="Info zu ${escapeHTML(role.name)}">ℹ️</button>
                    <span class="role-emoji">${role.emoji || '❓'}</span>
                    <h5 class="role-name">${escapeHTML(role.name)}</h5>
                    <div class="role-quantity">
                        <button data-role-id="${role.id}" data-change="-1" ${currentCount <= 0 ? 'disabled' : ''}>-</button>
                        <span>${currentCount}</span>
                        <button data-role-id="${role.id}" data-change="1">+</button>
                    </div>
                `;
                roleSelectionListDiv.appendChild(card); // Append card to the DIV
            });
            totalRolesSelectedSpan.textContent = totalRoles;
            updateValidation();
        }


        function handleRoleCountChange(roleId, change) {
             const currentCount = roles[roleId] || 0;
             const newCount = currentCount + change;
             if (newCount >= 0) roles[roleId] = newCount;
             renderRoleSelection(); // Re-render cards
        }

        function getTotalSelectedRoles() {
             return Object.values(roles).reduce((sum, count) => sum + count, 0);
        }

        function updateValidation() {
            const playerCount = players.length;
            const roleCount = getTotalSelectedRoles();
            assignRolesBtn.disabled = true;
            validationMessageP.className = 'invalid';
             if (playerCount === 0 && roleCount === 0) validationMessageP.textContent = 'Spieler hinzufügen und Rollen auswählen.';
             else if (playerCount < 3) validationMessageP.textContent = 'Mindestens 3 Spieler benötigt.'; // Min player check
             else if (roleCount < 1) validationMessageP.textContent = 'Wähle Rollen aus.';
             else if (playerCount !== roleCount) validationMessageP.textContent = `Spieler (${playerCount}) / Rollen (${roleCount})`; // Shorter message
             else {
                 validationMessageP.textContent = 'Spieler & Rollen passen!'; // Positive feedback
                 validationMessageP.className = 'valid';
                 assignRolesBtn.disabled = false;
             }
        }

        // --- Role Info Modal Logic ---
        function showRoleInfo(roleId) {
            const role = availableRoles.find(r => r.id === roleId);
            if (role) {
                modalRoleName.textContent = role.name;
                modalRoleDescDe.textContent = role.descDE;
                modalRoleDescEn.textContent = role.descEN;
                // Set initial language display state
                modalRoleDescDe.style.display = 'block';
                modalRoleDescEn.style.display = 'none';
                modalLangToggle.textContent = 'Show in English'; // Or 'Auf Englisch anzeigen'
                roleInfoModal.style.display = "block";
            } else {
                console.error("Role not found for ID:", roleId);
            }
        }

        function hideRoleInfo() {
            roleInfoModal.style.display = "none";
             // Optional: Add fade out animation class before hiding
        }

        function toggleModalLanguage() {
            const isEnVisible = modalRoleDescEn.style.display === 'block';
            modalRoleDescDe.style.display = isEnVisible ? 'block' : 'none';
            modalRoleDescEn.style.display = isEnVisible ? 'none' : 'block';
            modalLangToggle.textContent = isEnVisible ? 'Show in English' : 'Show in German'; // Or 'Auf Deutsch anzeigen'
        }


        // --- Assign Roles & Reveal (mostly unchanged logic) ---
        function assignRolesAndStartReveal() {
            if (players.length < 3 || players.length !== getTotalSelectedRoles()) return;
            let rolePool = [];
             availableRoles.forEach(roleData => {
                 const count = roles[roleData.id] || 0;
                 for (let i = 0; i < count; i++) rolePool.push(roleData);
             });
            let shuffledPlayers = shuffleArray([...players]);
            let shuffledRoles = shuffleArray(rolePool);
            assignedRoles = shuffledPlayers.map((player, index) => ({ player: player, roleData: shuffledRoles[index] }));
            currentPlayerIndex = 0;
            gameState.gamePhaseState = 'REVEAL';
            switchView('reveal');
            showNextPlayerInstruction();
        }

        function showNextPlayerInstruction() {
             if (currentPlayerIndex < assignedRoles.length) {
                const currentPlayerName = assignedRoles[currentPlayerIndex].player;
                revealInstructionP.textContent = `${escapeHTML(currentPlayerName)}, bitte Handy übernehmen.`; // Simpler instruction
                revealInstructionP.style.display = 'block';
                revealRoleBtn.style.display = 'inline-block';
                roleDisplayDiv.style.display = 'none';
                completionScreenDiv.style.display = 'none';
            } else showCompletion();
        }

        function revealRole() {
             if (currentPlayerIndex < assignedRoles.length) {
                 const assignment = assignedRoles[currentPlayerIndex];
                 const role = assignment.roleData;

                 if (!role || !role.descDE || !role.descEN) {
                     console.error("Role data incomplete for reveal:", assignment);
                     revealedRoleNameH3.textContent = `Du bist: ${role ? role.name : 'Unbekannt'}`;
                     revealedRoleDescDeP.textContent = "Fehler: Beschreibung nicht gefunden.";
                     revealedRoleDescEnP.textContent = "Error: Description not found.";
                 } else {
                    // Correctly add emoji with a space
                    revealedRoleNameH3.textContent = `Du bist: ${role.emoji || ''} ${role.name}`;
                    revealedRoleDescDeP.textContent = role.descDE;
                    revealedRoleDescEnP.textContent = role.descEN;
                 }

                 // Ensure correct initial visibility state
                 revealedRoleDescDeP.style.display = 'block';
                 revealedRoleDescEnP.style.display = 'none';
                 toggleLangBtn.textContent = 'Auf Englisch anzeigen'; // Set initial button text

                 revealInstructionP.style.display = 'none';
                 revealRoleBtn.style.display = 'none';
                 roleDisplayDiv.style.display = 'block';
             }
        }
        function toggleLanguage() {
             // Toggle visibility instead of text content
             const isEnVisible = revealedRoleDescEnP.style.display === 'block';
             revealedRoleDescDeP.style.display = isEnVisible ? 'block' : 'none';
             revealedRoleDescEnP.style.display = isEnVisible ? 'none' : 'block';
             // Update button text based on the new state
             toggleLangBtn.textContent = isEnVisible ? 'Auf Englisch anzeigen' : 'Auf Deutsch anzeigen';
        }
        function hideRoleAndProceed() {
            roleDisplayDiv.style.display = 'none';
            currentPlayerIndex++;
            if (currentPlayerIndex < assignedRoles.length) showNextPlayerInstruction();
            else showCompletion();
        }
        function showCompletion() { switchView('completion'); }


        // --- Facilitation Mode: Initialization (mostly unchanged logic) ---
        function initializeFacilitationMode() {
            console.log("Initializing facilitation mode...");
            gameState = { // Reset game state completely
                 players: assignedRoles.map((assignment, index) => ({
                    name: assignment.player,
                    roleData: assignment.roleData,
                    originalRoleData: assignment.roleData, // Store for Geist
                    status: 'Lebend', // 'Lebend', 'Tot', 'Geist'
                    isBuergermeister: false,
                    isProtected: false, // General protection flag (Bodyguard/Priest)
                    isBitten: false, // By Vampire
                    visitedPlayer: null, // Dorfmatratze target
                 })),
                 currentPhase: null,
                 gamePhaseState: null,
                 phaseNumber: 0,
                 dayTimerInterval: null,
                 dayTimerSeconds: 0,
                 nightActionSequence: [],
                 currentNightActionStep: -1,
                 nightSelections: { werwolfTarget: null, seherinCheck: null, protectedThisNight: null, healPotionUsedOn: null, poisonPotionTarget: null, amorPair: [], dorfmatratzeVisit: null, vampirTarget: null },
                 nightResults: { killedPlayerName: null, killedPlayerRole: null, poisonedPlayerName: null, poisonedPlayerRole: null, bittenPlayerName: null, bittenPlayerRole: null, holyWaterKillName: null, holyWaterKillRole: null, dorfmatratzeDeath: [], savedByBodyguard: null, savedByPriest: null, savedByHexe: null, savedByMatratze: null, turnedVerfluchter: null },
                 dailyDeaths: [],
                 buergermeister: null,
                 hexeHasHealPotion: true,
                 hexeHasPoisonPotion: true,
                 bodyguardLastProtected: null,
                 loverPair: [],
                 pendingHunterShot: false, hunterVictim: null, hunterTarget: null,
                 pendingAkwSelection: false, akwVictim: null, akwSelectedNeighbors: [],
                 lynchTarget: null, lynchVictimRole: null,
                 diedWithLover: null, diedFromHunter: null, diedFromAKW: [], diedFromVampireBite: null, diedFromDorfmatratze: [],
                 blumenkindUsedSave: !isRoleActive('blumenkind'), // Disable if role not present
                 blumenkindSavedPlayer: null,
                 reinigungskraftUsedClean: !isRoleActive('reinigungskraft'), // Disable if role not present
                 hideLynchRole: false,
                 gameOver: false,
                 winner: null,
                 initialPlayerOrder: [...initialPlayerOrder] // Keep the initial order
            };

             // --- Initial Faction Assignment for Lovers ---
             if (gameState.loverPair.length === 2) {
                 const lover1 = getPlayerData(gameState.loverPair[0]);
                 const lover2 = getPlayerData(gameState.loverPair[1]);
                 if (lover1) lover1.roleData.faction = 'Liebende'; // Assign lover faction immediately
                 if (lover2) lover2.roleData.faction = 'Liebende';
                 console.log("Lovers assigned faction:", gameState.loverPair);
             }

             renderGmPlayerList();
             updatePhaseDisplayAndControls(); // Set initial display
             dayResultsDisplayDiv.style.display = 'none';
             nightActionInterfaceDiv.style.display = 'none';
             dayActionAreaDiv.style.display = 'none'; // Hide day action area
             gameOverScreenDiv.style.display = 'none';

             console.log("Facilitation initialized:", gameState);
        }


        function switchToFacilitation() {
            console.log("Switching to Facilitation view...");
            initializeFacilitationMode();
            switchView('facilitation');
        }

        // --- Facilitation Mode: Phase & UI Management (mostly unchanged logic) ---
         function updatePhaseDisplayAndControls() {
              let phaseText = "Spiel initialisiert";
              let showDayTimer = false;
              let showNightInterface = false;
              let showDayActionArea = false;
              let showGameOver = false;

              // Hide all phase control buttons initially
              startNightBtn.style.display = 'none';
              startDayBtn.style.display = 'none';
              startVoteBtn.style.display = 'none';
              startNextNightBtn.style.display = 'none';

             // Determine visibility based on gamePhaseState
              switch (gameState.gamePhaseState) {
                  case 'SETUP':
                  case 'REVEAL': // Should not happen here, but safe fallback
                      phaseText = "Setup läuft...";
                      break;
                  case 'NIGHT_ACTION':
                      phaseText = `Nacht ${gameState.phaseNumber}`;
                      showNightInterface = true;
                      stopDayTimer(); // Ensure timer is stopped
                      break;
                  case 'NIGHT_RESULTS': // Brief state before Day Discussion
                      phaseText = `Ergebnisse Nacht ${gameState.phaseNumber}`; // Shorter text
                      startDayBtn.style.display = 'inline-block'; // Button to start the day discussion
                      // Use helper function to check if results div actually has content
                      dayResultsDisplayDiv.style.display = hasResultsContent(dayResultsDisplayDiv) ? 'block' : 'none';
                      break;
                  case 'DAY_DISCUSSION':
                      phaseText = `Tag ${gameState.phaseNumber} - Diskussion`;
                      startVoteBtn.style.display = 'inline-block';
                      dayResultsDisplayDiv.style.display = hasResultsContent(dayResultsDisplayDiv) ? 'block' : 'none';
                      // FIX 1: Don't show timer during discussion alone
                      // showDayTimer = true; // REMOVED
                      stopDayTimer(); // Ensure timer is stopped if discussion starts
                      break;
                 case 'DAY_MAYOR_VOTE':
                      phaseText = `Tag ${gameState.phaseNumber} - Bürgermeisterwahl`;
                      showDayActionArea = true; // Show election UI
                      dayResultsDisplayDiv.style.display = hasResultsContent(dayResultsDisplayDiv) ? 'block' : 'none';
                      showDayTimer = true; // Show timer with vote UI
                      // Timer started in setupMayorVoteUI
                      break;
                  case 'DAY_BLUMENKIND_SAVE':
                       phaseText = `Tag ${gameState.phaseNumber} - Blumenkind Rettung?`;
                       showDayActionArea = true;
                       dayResultsDisplayDiv.style.display = hasResultsContent(dayResultsDisplayDiv) ? 'block' : 'none';
                       // No timer during Blumenkind choice
                       break;
                  case 'DAY_LYNCH_VOTE':
                      phaseText = `Tag ${gameState.phaseNumber} - Lynch Abstimmung`;
                      showDayActionArea = true; // Show election UI
                      dayResultsDisplayDiv.style.display = hasResultsContent(dayResultsDisplayDiv) ? 'block' : 'none';
                      showDayTimer = true; // Show timer with vote UI
                      // Timer started in setupLynchVoteUI
                      break;
                  case 'DAY_LYNCH_CONFIRM':
                      phaseText = `Tag ${gameState.phaseNumber} - Lynch Bestätigung`;
                       showDayActionArea = true;
                       dayResultsDisplayDiv.style.display = hasResultsContent(dayResultsDisplayDiv) ? 'block' : 'none';
                       // Timer stopped before confirm, no timer shown here
                      break;
                  case 'DAY_REINIGUNGSKRAFT':
                      phaseText = `Tag ${gameState.phaseNumber} - Reinigungskraft Wahl`;
                       showDayActionArea = true;
                       dayResultsDisplayDiv.style.display = hasResultsContent(dayResultsDisplayDiv) ? 'block' : 'none';
                       // No timer during this choice
                      break;
                  case 'JAEGER_SHOT':
                      phaseText = `Jäger (${escapeHTML(gameState.hunterVictim)}) schießt!`;
                      showDayActionArea = true;
                      // No timer during Jaeger shot selection
                      break;
                  case 'AKW_SELECTION':
                      phaseText = `AKW (${escapeHTML(gameState.akwVictim)}) Effekt!`;
                      showDayActionArea = true;
                      // No timer during AKW selection
                      break;
                  case 'GAME_OVER':
                      phaseText = "Spiel beendet!";
                      showGameOver = true;
                      stopDayTimer();
                      break;
                  default: // Initial state before first night
                      phaseText = "Spiel bereit zum Start";
                      startNightBtn.style.display = 'inline-block';
                      startNightBtn.textContent = `Nacht ${gameState.phaseNumber + 1} starten`;
                      dayResultsDisplayDiv.style.display = 'none';
              }

              phaseDisplayDiv.textContent = phaseText;
              // Set display based on flags determined above
              dayTimerContainerDiv.style.display = showDayTimer ? 'block' : 'none';
              nightActionInterfaceDiv.style.display = showNightInterface ? 'block' : 'none';
              dayActionAreaDiv.style.display = showDayActionArea ? 'block' : 'none';
              gameOverScreenDiv.style.display = showGameOver ? 'block' : 'none';
              phaseControlsDiv.style.display = (startNightBtn.style.display !== 'none' || startDayBtn.style.display !== 'none' || startVoteBtn.style.display !== 'none' || startNextNightBtn.style.display !== 'none') ? 'block' : 'none';


               // Reset night interface elements if hiding
               if (!showNightInterface) {
                   playerSelectionAreaDiv.style.display = 'none';
                   hexeActionAreaDiv.style.display = 'none';
                   nightActionConfirmBtn.style.display = 'none';
                   nightActionSkipBtn.style.display = 'none';
                   nightActionNextBtn.style.display = 'none'; // Ensure Next is also hidden
               }
               // Hide specific day action controls if hiding day area
               if (!showDayActionArea) {
                   dayActionConfirmBtn.style.display = 'none';
                   dayActionSkipBtn.style.display = 'none';
                   reinigungskraftChoiceAreaDiv.style.display = 'none';
                   blumenkindSaveAreaDiv.style.display = 'none';
                   dayActionTargetListUl.innerHTML = ''; // Clear list when hiding
               }
         }

        // --- GM Player Grid Rendering ---
        function renderGmPlayerList() {
            gmPlayerGridDiv.innerHTML = ''; // Clear the grid
             // Use initial player order for consistent display
             const sortedPlayers = gameState.initialPlayerOrder.map(name => getPlayerData(name)).filter(Boolean);

            // Update Lover Display
            // Display logic moved inside the loop for individual card highlighting
            // Display general lover info if needed
            loverDisplayDiv.style.display = 'none'; // Hide by default, show if needed below or elsewhere
 
              sortedPlayers.forEach(player => {
                 const card = document.createElement('div');
                 card.className = 'gm-player-card'; // Base class
 
                 let statusClass = 'status-alive'; // Default
                  let statusText = player.status; // Lebend, Tot, Geist
                  let roleName = player.roleData?.name || '?'; // Add safety check
                  let roleEmoji = player.roleData?.emoji || '❓'; // Default emoji
                  let isLover = gameState.loverPair.includes(player.name);
                  // NEW: Add bite indicator, keep status as 'Lebend' visually until end of day
                  let biteIndicator = '';
                  if (player.isBitten && player.status === 'Lebend') {
                      biteIndicator = '🩸'; // Blood drop emoji
                      // Keep statusText 'Lebend' and statusClass 'status-alive' for display purposes
                  } else if (player.status === 'Tot') {
                     statusClass = 'status-dead';
                     // Don't show role if Reinigungskraft hid it
                     if (gameState.hideLynchRole && player.name === gameState.lynchTarget) {
                         roleName = '???';
                         roleEmoji = '❓'; // Hide emoji too
                     }
                 } else if (player.status === 'Geist') {
                     statusClass = 'status-geist';
                      roleName = player.originalRoleData?.name || '?'; // Show original role for Geist (safe access)
                     roleEmoji = player.originalRoleData?.emoji || '👻'; // Show original emoji or ghost
                     statusText = 'Geist';
                 }
 
                 card.classList.add(statusClass); // Add status class for styling
                 // MODIFIED: Add is-lover class for border styling
                 if (isLover && player.status !== 'Tot' && player.status !== 'Geist') { // Apply only if not dead/geist
                     card.classList.add('is-lover');
                 }
 
                 card.innerHTML = `
                     <div class="gm-player-emoji">${roleEmoji}</div>
                     <div class="gm-player-name">
                         ${biteIndicator}${escapeHTML(player.name)}
                         ${player.isBuergermeister ? '<span class="mayor-icon">👑</span>' : ''}
                         ${isLover ? '<span class="lover-icon">💘</span>' : ''}
                      </div>
                     <div class="gm-player-role">${escapeHTML(roleName)}</div>
                     <div class="gm-player-status ${statusClass}">${statusText}</div>
                  `;
                 gmPlayerGridDiv.appendChild(card);
             });
        }


        // --- Timer Functions (unchanged logic) ---
        function formatTime(totalSeconds) {
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        function tickDayTimer() {
            gameState.dayTimerSeconds++;
            dayTimerDisplayDiv.textContent = formatTime(gameState.dayTimerSeconds);
        }
        function startDayTimer() {
            stopDayTimer();
            gameState.dayTimerSeconds = 0;
            dayTimerDisplayDiv.textContent = formatTime(0);
            // Timer container visibility handled by updatePhaseDisplayAndControls
            gameState.dayTimerInterval = setInterval(tickDayTimer, 1000);
            console.log("Day timer started.");
        }
        function stopDayTimer() {
            if (gameState.dayTimerInterval) {
                clearInterval(gameState.dayTimerInterval);
                gameState.dayTimerInterval = null;
                console.log("Day timer stopped.");
            }
        }


        // --- Night Action Core Logic (mostly unchanged logic) ---
        function buildNightSequence() {
             const sequence = ['intro']; // Always start with intro

             // First Night Only Roles
             if (gameState.phaseNumber === 1) {
                 if (isRoleActive('amor')) sequence.push('amor');
                 if (isRoleActive('freimaurer')) sequence.push('freimaurer');
                 // Add 1st night Blumenkind here if using that version
             }

             // Standard Night Roles (in rough order of action)
             if (isRoleActive('leibwaechter')) sequence.push('leibwaechter');
             if (isRoleActive('priester')) sequence.push('priester');
             if (isRoleActive('dorfmatratze')) sequence.push('dorfmatratze');
             if (isRoleActive('werwolf')) sequence.push('werwolf');
             if (isRoleActive('vampir')) sequence.push('vampir'); // Vampires act
             if (isRoleActive('hexe') && (gameState.hexeHasHealPotion || gameState.hexeHasPoisonPotion)) {
                 sequence.push('hexe');
             }
             if (isRoleActive('seherin')) sequence.push('seherin');

             sequence.push('outro'); // Always end with outro
             gameState.nightActionSequence = sequence;
             console.log("Built night sequence:", gameState.nightActionSequence);
        }

        function startNightPhase() {
             console.log("Starting Night Phase...");
             if (gameState.gameOver) return; // Don't start if game is over

             if (gameState.currentPhase === 'Tag' || gameState.gamePhaseState === 'NIGHT_RESULTS') { // Allow starting from results too
                 // Reset things from the previous day before starting night
                 if (gameState.currentPhase === 'Tag') gameState.phaseNumber++;
                 stopDayTimer();
                 gameState.dayTimerSeconds = 0;
                 dayResultsDisplayDiv.style.display = 'none'; // Hide previous day results
                 dayResultsDisplayDiv.innerHTML = ''; // Clear content too
                 gameState.blumenkindSavedPlayer = null; // Reset Blumenkind save
                 gameState.hideLynchRole = false; // Reset Reinigungskraft effect
                 gameState.dailyDeaths = []; // Clear deaths from previous day

                 // Update bodyguard's last protected at the END of the day/start of new night
                 gameState.bodyguardLastProtected = gameState.nightSelections.protectedThisNight;
                 console.log("Updated bodyguardLastProtected to:", gameState.bodyguardLastProtected);
             } else if (gameState.phaseNumber === 0) {
                 gameState.phaseNumber = 1; // First night
                 gameState.bodyguardLastProtected = null; // Ensure reset
             }
             startNextNightBtn.textContent = `Nacht ${gameState.phaseNumber + 1} starten`;

             // Reset night-specific state
             gameState.currentPhase = 'Nacht';
             gameState.gamePhaseState = 'NIGHT_ACTION';
             gameState.nightSelections = { // Clear selections
                 werwolfTarget: null, seherinCheck: null, protectedThisNight: null,
                 healPotionUsedOn: null, poisonPotionTarget: null,
                 amorPair: gameState.phaseNumber === 1 ? [] : gameState.loverPair, // Keep Amor pair after Night 1
                 dorfmatratzeVisit: null, vampirTarget: null,
             };
              gameState.nightResults = { // Clear results
                 killedPlayerName: null, killedPlayerRole: null, poisonedPlayerName: null, poisonedPlayerRole: null,
                 bittenPlayerName: null, bittenPlayerRole: null, holyWaterKillName: null, holyWaterKillRole: null,
                 dorfmatratzeDeath: [], savedByBodyguard: null, savedByPriest: null, savedByHexe: null, savedByMatratze: null, turnedVerfluchter: null
              };
              gameState.diedWithLover = null; // Clear specific display flags
              gameState.diedFromDorfmatratze = [];

             // Rebuild sequence for potential role deaths
             buildNightSequence();
             // MODIFIED: Set step to 0 and call process directly
             gameState.currentNightActionStep = 0;

             // Reset protection status on players
             gameState.players.forEach(p => {
                 p.isProtected = false;
                 p.visitedPlayer = null; // Reset Dorfmatratze visit status
             });

             updatePhaseDisplayAndControls();
             // MODIFIED: Call processNightActionStep directly for step 0
             processNightActionStep();
        }

         function processNightActionStep() {
              // Check for game over before processing
              if (gameState.gameOver || gameState.gamePhaseState !== 'NIGHT_ACTION') return;

             // ADDED LOG at the beginning
             console.log(`PROCESS_STEP: Processing step index ${gameState.currentNightActionStep}, ID: ${gameState.nightActionSequence[gameState.currentNightActionStep] || 'OUT_OF_BOUNDS'}`);

             if (gameState.currentNightActionStep < 0 || gameState.currentNightActionStep >= gameState.nightActionSequence.length) {
                 console.error("Invalid night action step index:", gameState.currentNightActionStep);
                 // Attempt to end gracefully if index is exactly sequence length (meaning outro was processed)
                 if (gameState.currentNightActionStep === gameState.nightActionSequence.length) {
                    console.log("Attempting to end night actions as step index is at sequence length.");
                    endNightActions();
                 } else {
                    console.error("Night step index is invalid and not the expected end state.");
                 }
                 return;
             }

             const currentStepId = gameState.nightActionSequence[gameState.currentNightActionStep];
             console.log(`Processing Night Step ${gameState.currentNightActionStep}: ${currentStepId}`);

             // Reset common elements for the step
             playerSelectionAreaDiv.style.display = 'none';
             hexeActionAreaDiv.style.display = 'none';
             nightActionConfirmBtn.style.display = 'none';
             nightActionSkipBtn.style.display = 'none';
             // Default hide 'Next' button, only show if needed
             nightActionNextBtn.style.display = 'none';
             gmPromptDiv.innerHTML = '';
             targetPlayerListUl.innerHTML = ''; // Clear any previous target list
             seerResultDisplayP.style.display = 'none';
             blumenkindResultDisplayP.style.display = 'none';


             let skipAction = false; // Flag if role is inactive and needs skipping
             // REMOVED: autoAdvanceDelay = 0;
             const roleDef = availableRoles.find(r => r.id === currentStepId);
             const roleName = roleDef ? roleDef.name : currentStepId.charAt(0).toUpperCase() + currentStepId.slice(1); // Capitalize fallback


             switch (currentStepId) {
                 case 'intro':
                     gmPromptDiv.innerHTML = "<p>GM: Sage 'Das Dorf schläft ein...'</p><p>Alle Spieler schließen die Augen.</p>";
                     nightActionNextBtn.style.display = 'inline-block'; // Show next for intro
                     break;

                 case 'amor': // First Night Only
                      if (isRoleActive('amor')) {
                          gmPromptDiv.innerHTML = `<p>GM: Sage '${roleName}, erwache!'</p>`;
                          nightActionNextBtn.style.display = 'inline-block'; // Next triggers selection
                      } else skipAction = true;
                     break;

                 case 'freimaurer': // First Night Only
                      if (isRoleActive('freimaurer')) {
                          gmPromptDiv.innerHTML = `<p>GM: Sage '${roleName}, erwachen und erkennen sich!'</p>`;
                          const masons = gameState.players.filter(p => p.roleData.id === 'freimaurer' && p.status === 'Lebend'); // Ensure living
                          if (masons.length > 0) {
                              gmPromptDiv.innerHTML += `<p><i>(GM Info: Freimaurer sind: ${masons.map(p => escapeHTML(p.name)).join(', ')})</i></p>`;
                          } else {
                               gmPromptDiv.innerHTML += `<p><i>(GM Info: Keine (lebenden) Freimaurer)</i></p>`;
                          }
                          gmPromptDiv.innerHTML += `<p>GM: Sage '${roleName} schlafen wieder ein.'</p>`;
                          // MODIFIED: Show 'Next' button instead of auto-advance
                          nightActionNextBtn.style.display = 'inline-block';
                      } else skipAction = true;
                      break;

                 case 'leibwaechter':
                 case 'priester':
                 case 'dorfmatratze':
                 case 'werwolf':
                 case 'vampir':
                 case 'seherin':
                     if (isRoleActive(currentStepId)) {
                         gmPromptDiv.innerHTML = `<p>GM: Sage '${roleName}, erwache!'</p>`;
                         nightActionNextBtn.style.display = 'inline-block'; // Next triggers selection
                     } else skipAction = true;
                     break;

                  case 'hexe':
                       // Check if Hexe needs to act at all (only if potions available OR wolf target exists for heal)
                       const wolfTarget = getPlayerData(gameState.nightSelections.werwolfTarget);
                       const wolfTargetAlive = wolfTarget && wolfTarget.status === 'Lebend';
                       if (isRoleActive('hexe') && (gameState.hexeHasHealPotion || gameState.hexeHasPoisonPotion || wolfTargetAlive) ) {
                       gmPromptDiv.innerHTML = `<p>GM: Sage '${roleName}, erwache!'</p>`;
                       nightActionNextBtn.style.display = 'inline-block'; // Next triggers Hexe UI setup
                       } else {
                           skipAction = true; // Skip if no potions and no target to potentially heal
                       }
                      break;

                 case 'outro':
                     gmPromptDiv.innerHTML = "<p>Nachtaktionen abgeschlossen.</p><p>GM: Sage 'Das Dorf erwacht!'</p>";
                     // MODIFIED: Show 'Next' button to end night
                     nightActionNextBtn.style.display = 'inline-block';
                     nightActionNextBtn.dataset.actionType = 'end_night'; // Mark button to trigger endNightActions
                     break;

                 default:
                     console.error("Unbekannter Nachtaktions-Schritt:", currentStepId);
                     gmPromptDiv.innerHTML = "<p>Fehler im Nachtablauf.</p>";
                     // MODIFIED: Show 'Next' button to try and recover/advance
                     nightActionNextBtn.style.display = 'inline-block';
             }

             if (skipAction) {
                  // MODIFIED: Role is not active, prompt and show 'Next' button
                  gmPromptDiv.innerHTML = `<p>GM: Sage '${roleName}, erwache!'</p>`;
                  gmPromptDiv.innerHTML += `<p class="gm-note"><i>(GM Info: Rolle nicht aktiv / keine lebenden Spieler / keine Aktion möglich)</i></p>`; // Use gm-note class
                  gmPromptDiv.innerHTML += `<p>GM: Sage '${roleName}, schläft wieder ein.'</p>`;
                  nightActionNextBtn.style.display = 'inline-block';
             }

             // Ensure skip button action type is cleared if not explicitly set
             if (nightActionSkipBtn.style.display === 'none') {
                 nightActionSkipBtn.dataset.actionType = '';
             }
             // Ensure confirm button action type is cleared if not explicitly set
             if (nightActionConfirmBtn.style.display === 'none') {
                 nightActionConfirmBtn.dataset.actionType = '';
             }
             // Clear action type for 'Next' button unless it's the special outro button
             if (nightActionNextBtn.dataset.actionType !== 'end_night') {
                 nightActionNextBtn.dataset.actionType = '';
             }
         }

         function handleNightActionNext() {
             if (gameState.currentNightActionStep < 0 || gameState.gameOver) return;

             const currentStepIndex = gameState.currentNightActionStep; // Capture index *before* potential advancement
             const currentStepId = gameState.nightActionSequence[currentStepIndex];

             console.log(`HANDLE_NEXT: Clicked. Current step index: ${currentStepIndex}, ID: ${currentStepId}`);

             // Case 1: Click is explicitly to end the night (on Outro step)
             if (nightActionNextBtn.dataset.actionType === 'end_night' && currentStepId === 'outro') {
                 console.log("HANDLE_NEXT: Ending night actions via outro button.");
                 endNightActions();
                 return;
             }

             // Case 2: Click is to initiate the action setup for the current interactive step
             const interactiveSteps = ['amor', 'leibwaechter', 'priester', 'dorfmatratze', 'werwolf', 'vampir', 'hexe', 'seherin'];
             const isInteractive = interactiveSteps.includes(currentStepId);
             const roleIsActive = isRoleActive(currentStepId);
             const isHexeButNoAction = currentStepId === 'hexe' && roleIsActive && !gameState.hexeHasHealPotion && !gameState.hexeHasPoisonPotion && !(getPlayerData(gameState.nightSelections.werwolfTarget)?.status === 'Lebend');
              // Check if Confirm/Skip buttons are hidden - if they are visible, this 'Weiter' click shouldn't happen or should be ignored.
             const selectionInProgress = nightActionConfirmBtn.style.display !== 'none' || nightActionSkipBtn.style.display !== 'none';


             if (isInteractive && roleIsActive && !isHexeButNoAction && !selectionInProgress) {
                  // This 'Weiter' click IS meant to start the selection process for the current step.
                  console.log(`HANDLE_NEXT: Initiating action setup for step: ${currentStepId}`);

              const roleDef = availableRoles.find(r => r.id === currentStepId);
              const roleName = roleDef ? roleDef.name : currentStepId;

              // Helper to setup standard selection
              const setupSelection = (actionType, confirmText, promptText, requiredSelections = 1) => {
                  gmPromptDiv.innerHTML += `<p>${escapeHTML(roleName)}: ${promptText}</p>`;
                  renderTargetPlayerList(actionType, requiredSelections);
                      if (targetPlayerListUl.children.length > 0 && !targetPlayerListUl.querySelector('.target-dead')) {
                      playerSelectionAreaDiv.style.display = 'block';
                      nightActionConfirmBtn.textContent = confirmText;
                          nightActionConfirmBtn.disabled = true;
                      nightActionConfirmBtn.style.display = 'inline-block';
                          nightActionConfirmBtn.dataset.actionType = actionType;
                          nightActionNextBtn.style.display = 'none'; // Hide Weiter during selection
                           if (['leibwaechter', 'priester', 'dorfmatratze', 'seherin'].includes(actionType)) {
                           nightActionSkipBtn.textContent = "Überspringen";
                           nightActionSkipBtn.dataset.actionType = `${actionType}_skip`;
                           nightActionSkipBtn.style.display = 'inline-block';
                       }
                  } else {
                          // No valid targets, show message and 'Weiter' again to skip this step
                      gmPromptDiv.innerHTML += `<p class="gm-note"><i>(GM Info: Keine gültigen Ziele verfügbar)</i></p>`; // Use gm-note class
                      gmPromptDiv.innerHTML += `<p>GM: Sage '${roleName}, schläft wieder ein.'</p>`;
                          nightActionNextBtn.style.display = 'inline-block';
                         playerSelectionAreaDiv.style.display = 'none';
             nightActionConfirmBtn.style.display = 'none';
             nightActionSkipBtn.style.display = 'none';
                      }
                  };

                  switch (currentStepId) {
                      case 'amor': setupSelection('amor', "Paar bestätigen", "Wähle zwei Spieler.", 2); break;
                      case 'leibwaechter': setupSelection('leibwaechter', "Ziel bestätigen", "Wähle einen Spieler zum Beschützen."); break;
                      case 'priester': setupSelection('priester', "Ziel bestätigen", "Wähle einen Spieler zum Beschützen."); break;
                      case 'dorfmatratze': setupSelection('dorfmatratze', "Besuch bestätigen", "Wähle einen Spieler zum Besuchen."); break;
                      case 'werwolf': setupSelection('werwolf', "Opfer bestätigen", "Wählt euer Opfer."); break;
                      case 'vampir': setupSelection('vampir', "Biss bestätigen", "Wählt euer Opfer zum Beißen."); break;
                      case 'hexe': setupHexeInterface(); nightActionNextBtn.style.display = 'none'; break;
                      case 'seherin': setupSelection('seherin', "Ziel bestätigen", "Wähle einen Spieler zur Überprüfung."); break;
                      default: console.warn("Interaction setup requested for unexpected step:", currentStepId); break;
                  }
                  // Return here, setup is done, wait for user input (confirm/skip/hexe actions)
                  return;
             }

             // Case 3: Click is meant to advance past a non-interactive step, an inactive role,
             // or a step that just finished (confirm/skip was handled, advanceNightStep called, and process showed Weiter).
             console.log(`HANDLE_NEXT: Advancing past step: ${currentStepId}`);
             advanceNightStep();
        }

        function advanceNightStep() {
             // Condition should now work correctly as it's only called for steps >= 0
             if (gameState.currentNightActionStep >= 0 && !gameState.gameOver) {
                 const oldStep = gameState.currentNightActionStep;
                 // Clear previous action types from buttons before processing next step
                 nightActionNextBtn.dataset.actionType = '';
                 nightActionConfirmBtn.dataset.actionType = '';
                 nightActionSkipBtn.dataset.actionType = '';

                 gameState.currentNightActionStep++; // Increments step
                 console.log(`ADVANCE_STEP: Incremented step from ${oldStep} to ${gameState.currentNightActionStep}`); // ADDED LOG
                 processNightActionStep(); // Processes the NEW step
             } else {
                 console.log("Cannot advance night step, sequence finished or game over.");
                 // Check the specific reason
                 if (gameState.gameOver) {
                     console.log("Reason: Game is over.");
                 } else {
                     console.log(`Reason: currentNightActionStep is ${gameState.currentNightActionStep}`);
                 }
             }
        }


        // --- Specific Night Action Handlers (Hexe, Target Selection, Confirmation) ---
        // --- Hexe Interface (mostly unchanged logic) ---
        function setupHexeInterface() {
            console.log("Setting up Hexe interface...");
             hexeActionAreaDiv.style.display = 'block';
             playerSelectionAreaDiv.style.display = 'none'; // Hide player list initially
             nightActionConfirmBtn.style.display = 'none'; // Hide confirm button initially
             nightActionSkipBtn.textContent = "Fertig"; // Use skip as 'Done' for Hexe
             nightActionSkipBtn.dataset.actionType = 'hexe_skip'; // Identify skip button
             nightActionSkipBtn.style.display = 'inline-block'; // Show Skip/Done button
             nightActionSkipBtn.disabled = false; // Enable it

             // 1. Display Werewolf Target
             const wolfTargetName = gameState.nightSelections.werwolfTarget;
             const wolfTarget = getPlayerData(wolfTargetName);
             const wolfTargetAlive = wolfTarget && wolfTarget.status === 'Lebend';

             if (wolfTargetAlive) {
                 hexeWolfTargetInfoP.textContent = `Werwolf-Ziel: ${escapeHTML(wolfTargetName)}`;
                 hexeWolfTargetInfoP.style.display = 'block';
             } else {
                  hexeWolfTargetInfoP.textContent = wolfTargetName ? `Werwolf-Ziel (${escapeHTML(wolfTargetName)}) ist bereits tot oder wurde nicht gewählt.` : 'Werwölfe haben niemanden gewählt.';
                  hexeWolfTargetInfoP.style.display = 'block';
             }

             // 2. Setup Heal Potion Control
             const healBtnYes = hexeHealControlDiv.querySelector('button[data-action="yes"]');
             const healBtnNo = hexeHealControlDiv.querySelector('button[data-action="no"]');
             const healUsedSpan = hexeHealControlDiv.querySelector('.potion-used');
             const healButtonsArea = hexeHealControlDiv.querySelectorAll('button'); // Yes/No buttons + label span
             const healLabel = hexeHealControlDiv.querySelector('span:not(.potion-used)');
             const canHeal = gameState.hexeHasHealPotion && wolfTargetAlive; // Can only heal living target

             if (gameState.hexeHasHealPotion) {
                 hexeHealControlDiv.style.display = 'flex'; // Use flex display
                 healLabel.style.display = 'inline';
                 healUsedSpan.style.display = 'none';
                 healBtnYes.style.display = 'inline-block';
                 healBtnNo.style.display = 'inline-block';
                 healBtnYes.disabled = !canHeal; // Enable only if target exists and alive
                 healBtnNo.disabled = false; // Can always choose 'No'
                  // Add info if potion is available but target is dead/missing
                 if (!wolfTargetAlive) {
                     healUsedSpan.textContent = 'Kein lebendes Ziel zum Heilen.';
                     healUsedSpan.style.display = 'inline';
                 }

             } else {
                 hexeHealControlDiv.style.display = 'flex'; // Show 'used' status
                 healLabel.style.display = 'none';
                 healBtnYes.style.display = 'none';
                 healBtnNo.style.display = 'none';
                 healUsedSpan.textContent = 'Heiltrank bereits benutzt.';
                 healUsedSpan.style.display = 'inline';
             }

             // 3. Setup Poison Potion Control
            const poisonBtnYes = hexePoisonControlDiv.querySelector('button[data-action="yes"]');
            const poisonBtnNo = hexePoisonControlDiv.querySelector('button[data-action="no"]');
            const poisonUsedSpan = hexePoisonControlDiv.querySelector('.potion-used');
             const poisonLabel = hexePoisonControlDiv.querySelector('span:not(.potion-used)');


             if (gameState.hexeHasPoisonPotion) {
                 hexePoisonControlDiv.style.display = 'flex';
                 poisonLabel.style.display = 'inline';
                 poisonUsedSpan.style.display = 'none';
                 poisonBtnYes.style.display = 'inline-block';
                 poisonBtnNo.style.display = 'inline-block';
                 poisonBtnYes.disabled = false;
                 poisonBtnNo.disabled = false;
             } else {
                 hexePoisonControlDiv.style.display = 'flex'; // Show 'used' status
                 poisonLabel.style.display = 'none';
                 poisonBtnYes.style.display = 'none';
                 poisonBtnNo.style.display = 'none';
                 poisonUsedSpan.textContent = 'Gifttrank bereits benutzt.';
                 poisonUsedSpan.style.display = 'inline';
             }
        }

        function handleHexePotionClick(potionType, action) {
            console.log(`Hexe potion click: ${potionType}, Action: ${action}`);

            if (potionType === 'heal') {
                const healControl = hexeHealControlDiv;
                const healBtnYes = healControl.querySelector('button[data-action="yes"]');
                const healBtnNo = healControl.querySelector('button[data-action="no"]');
                const healUsedSpan = healControl.querySelector('.potion-used');
                const healLabel = healControl.querySelector('span:not(.potion-used)');


                healBtnYes.style.display = 'none'; // Hide buttons after choice
                healBtnNo.style.display = 'none';
                healLabel.style.display = 'none'; // Hide label text too


                if (action === 'yes' && gameState.nightSelections.werwolfTarget) {
                    gameState.nightSelections.healPotionUsedOn = gameState.nightSelections.werwolfTarget;
                    healUsedSpan.textContent = `Heilt ${escapeHTML(gameState.nightSelections.healPotionUsedOn)}.`;
                    console.log("Heal potion selected for:", gameState.nightSelections.healPotionUsedOn);
                } else {
                    healUsedSpan.textContent = 'Heiltrank nicht eingesetzt.';
                    gameState.nightSelections.healPotionUsedOn = null; // Ensure it's null if 'No'
                }
                 healUsedSpan.style.display = 'inline';
            } else if (potionType === 'poison') {
                 const poisonControl = hexePoisonControlDiv;
                const poisonBtnYes = poisonControl.querySelector('button[data-action="yes"]');
                const poisonBtnNo = poisonControl.querySelector('button[data-action="no"]');
                const poisonUsedSpan = poisonControl.querySelector('.potion-used');
                 const poisonLabel = poisonControl.querySelector('span:not(.potion-used)');

                poisonBtnYes.style.display = 'none'; // Hide buttons after choice
                poisonBtnNo.style.display = 'none';
                 poisonLabel.style.display = 'none'; // Hide label text too


                if (action === 'yes') {
                    poisonUsedSpan.textContent = 'Wähle Opfer für Gift...';
                    poisonUsedSpan.style.display = 'inline';
                    renderTargetPlayerList('hexe_poison'); // Show targets for poison
                    if (targetPlayerListUl.children.length > 0 && !targetPlayerListUl.querySelector('.target-dead')) {
                        playerSelectionAreaDiv.style.display = 'block';
                        nightActionSkipBtn.disabled = true; // Disable skip while choosing poison target
                        nightActionConfirmBtn.textContent = "Gift bestätigen"; // Specific confirm button
                        nightActionConfirmBtn.disabled = true; // Enable after selection
                        nightActionConfirmBtn.style.display = 'inline-block';
                         nightActionConfirmBtn.dataset.actionType = 'hexe_poison'; // Mark button type
                    } else {
                         poisonUsedSpan.textContent = 'Gift nicht eingesetzt (keine Ziele).';
                         nightActionSkipBtn.disabled = false; // Re-enable skip if no targets
                    }
                } else {
                    poisonUsedSpan.textContent = 'Gifttrank nicht eingesetzt.';
                    poisonUsedSpan.style.display = 'inline';
                    gameState.nightSelections.poisonPotionTarget = null; // Ensure null if 'No'
                    nightActionSkipBtn.disabled = false; // Re-enable skip
                }
            }
        }

        // --- Target List Rendering (Night - mostly unchanged logic) ---
        function renderTargetPlayerList(actionType, requiredSelections = 1) {
             targetPlayerListUl.innerHTML = '';
             let title = '';
             seerResultDisplayP.style.display = 'none';

             const livingPlayers = getLivingPlayers();
             let eligibleTargets = [];
              const actingPlayer = gameState.players.find(p => p.roleData.id === actionType && p.status === 'Lebend');


             // Determine eligible targets based on action type
             switch (actionType) {
                 case 'amor':
                      title = 'Wähle zwei Spieler für das Liebespaar:';
                      eligibleTargets = livingPlayers; // Can choose self
                      break;
                 case 'leibwaechter':
                     title = 'Wähle einen Spieler zum Beschützen:';
                      eligibleTargets = livingPlayers.filter(p =>
                          p.roleData.id !== 'leibwaechter' && // Can't protect self
                          p.name !== gameState.bodyguardLastProtected
                      );
                     break;
                 case 'priester':
                     title = 'Wähle einen Spieler zum Beschützen:';
                       // Standard rules often allow priest to protect self, check game rules if needed
                      eligibleTargets = livingPlayers; //.filter(p => p.roleData.id !== 'priester');
                      break;
                 case 'dorfmatratze':
                     title = 'Wähle einen Spieler zum Besuchen:';
                     eligibleTargets = livingPlayers.filter(p => p.roleData.id !== 'dorfmatratze'); // Cannot visit self
                     break;
                 case 'werwolf':
                     title = 'Wählt ein Opfer:';
                      // Wolves cannot target other wolves. CAN target Vampires.
                      eligibleTargets = livingPlayers.filter(p => p.roleData.faction !== 'Werwolf');
                      break;
                 case 'vampir':
                     title = 'Wählt ein Opfer zum Beißen:';
                      // Vampires cannot target other vampires. CAN target Werwölfe.
                      eligibleTargets = livingPlayers.filter(p => p.roleData.id !== 'vampir');
                     break;
                 case 'seherin':
                     title = 'Wähle einen Spieler zur Überprüfung:';
                      eligibleTargets = livingPlayers.filter(p => p.roleData.id !== 'seherin'); // Can't check self
                     break;
                 case 'hexe_poison':
                     title = 'Wähle ein Opfer für den Gifttrank:';
                      eligibleTargets = livingPlayers.filter(p => p.roleData.id !== 'hexe'); // Can't poison self
                     break;
                 // Day Actions (use renderDayActionTargetList)
                 default:
                     console.error("Unknown actionType for renderTargetPlayerList:", actionType);
                     return;
             }

             selectionTitleH4.textContent = title;
             targetPlayerListUl.dataset.requiredSelections = requiredSelections; // Store how many needed
             targetPlayerListUl.dataset.actionType = actionType; // Store action type

             if (eligibleTargets.length === 0) {
                 targetPlayerListUl.innerHTML = '<li class="target-dead">Keine gültigen Ziele verfügbar.</li>';
                 nightActionConfirmBtn.disabled = true; // Cannot confirm if no targets (except maybe Hexe?)
                 if (actionType === 'hexe_poison') nightActionSkipBtn.disabled = false; // Re-enable skip for Hexe
                 else if (['leibwaechter', 'priester', 'dorfmatratze', 'seherin'].includes(actionType)) nightActionSkipBtn.disabled = false; // Re-enable skip for optional roles
             } else {
                 eligibleTargets.forEach(player => {
                     const li = document.createElement('li');
                     li.dataset.playerName = player.name;
                     li.textContent = escapeHTML(player.name);
                     li.addEventListener('click', () => handleTargetSelection(li, actionType, requiredSelections));
                     targetPlayerListUl.appendChild(li);
                 });
                 nightActionConfirmBtn.disabled = true; // Ensure disabled until selection met
                  if (['leibwaechter', 'priester', 'dorfmatratze', 'seherin'].includes(actionType)) {
                      nightActionSkipBtn.disabled = false; // Enable skip alongside targets
                  }
             }
         }


        // --- Target Selection (Night - mostly unchanged logic) ---
         function handleTargetSelection(selectedLi, actionType, requiredSelections = 1) {
             const playerName = selectedLi.dataset.playerName;
             if (!playerName || selectedLi.classList.contains('target-dead')) return; // Ignore clicks on dead/invalid

             console.log(`${actionType} selection: ${playerName}`);
             const targetList = selectedLi.closest('ul'); // Either night or day list

             if (!targetList) return; // Safety check
             const confirmBtn = targetList.id === 'targetPlayerList' ? nightActionConfirmBtn : dayActionConfirmBtn;


             if (requiredSelections === 1) {
                 // Single selection mode: clear previous, highlight new
                 const currentlySelected = targetList.querySelector('.selected-target');
                 if (currentlySelected) currentlySelected.classList.remove('selected-target');
                 selectedLi.classList.add('selected-target');
                 if (confirmBtn) confirmBtn.disabled = false; // Enable confirm for single selection
             } else {
                 // Multi-selection mode (e.g., Amor, AKW)
                 const maxSelections = parseInt(targetList.dataset.maxSelections || targetList.dataset.requiredSelections, 10); // Use max if available (AKW)

                 if (selectedLi.classList.contains('selected-target')) {
                     selectedLi.classList.remove('selected-target');
                 } else {
                      const currentSelections = targetList.querySelectorAll('.selected-target').length;
                      if (currentSelections < maxSelections) {
                         selectedLi.classList.add('selected-target');
                      } else {
                          console.log(`Max selections (${maxSelections}) reached for ${actionType}.`);
                          // Optional: Flash indication or ignore
                          return;
                      }
                 }
                 const finalSelections = targetList.querySelectorAll('.selected-target').length;
                 // Enable confirm only when exact number selected (Amor) or >= 0 and <= max (AKW)
                 if (confirmBtn) {
                     if (actionType === 'akw') {
                         confirmBtn.disabled = false; // Always enabled for AKW (0 to max)
                     } else {
                         confirmBtn.disabled = (finalSelections !== requiredSelections);
                     }
                 }
             }

             // Store selection immediately (overwritten if multi-select changes)
             // For multi-select, confirmNightAction/confirmDayAction will read all selected targets
             const selectedNames = Array.from(targetList.querySelectorAll('.selected-target')).map(li => li.dataset.playerName);

             // Update gameState based on actionType (Primary target stored, confirm reads final list)
             // Only update night selections here
             if (targetList.id === 'targetPlayerList') {
                 switch (actionType) {
                     case 'amor': break; // Stored on confirm
                     case 'werwolf': gameState.nightSelections.werwolfTarget = selectedNames[0] || null; break;
                     case 'seherin':
                         gameState.nightSelections.seherinCheck = selectedNames[0] || null;
                         displaySeerResult(gameState.nightSelections.seherinCheck);
                         break;
                     case 'leibwaechter':
                     case 'priester': gameState.nightSelections.protectedThisNight = selectedNames[0] || null; break;
                     case 'dorfmatratze': gameState.nightSelections.dorfmatratzeVisit = selectedNames[0] || null; break;
                     case 'vampir': gameState.nightSelections.vampirTarget = selectedNames[0] || null; break;
                     case 'hexe_poison': gameState.nightSelections.poisonPotionTarget = selectedNames[0] || null; break;
                 }
            } else {
                 // Store day selections (though usually done on confirm)
                 switch(actionType) {
                     case 'mayor': gameState.buergermeister = selectedNames[0] || null; break; // Tentative mayor
                     case 'lynch': gameState.lynchTarget = selectedNames[0] || null; break; // Tentative lynch
                     case 'jaeger': gameState.hunterTarget = selectedNames[0] || null; break; // Tentative shot
                     case 'blumenkind_save': gameState.blumenkindSavedPlayer = selectedNames[0] || null; break; // Tentative save
                     // AKW handled on confirm due to multi-select
                 }
            }
         }


         // --- Seer Result Display (unchanged logic) ---
         function displaySeerResult(targetName) {
              if (!targetName) {
                  seerResultDisplayP.style.display = 'none';
                  return;
              }
              const targetPlayer = getPlayerData(targetName);
              if (targetPlayer) {
                    // Check current roleData, accounting for Verfluchter state
                    let isSeenAsWolf = targetPlayer.roleData.id === 'werwolf';
                    // Special check: Günstling is seen as NOT wolf
                    if (targetPlayer.roleData.id === 'guenstling') isSeenAsWolf = false;

                    seerResultDisplayP.textContent = `Ergebnis für ${escapeHTML(targetName)}: ${isSeenAsWolf ? 'Ist Werwolf' : 'Ist KEIN Werwolf'}`;
                    seerResultDisplayP.style.display = 'inline-block';
              } else {
                  seerResultDisplayP.textContent = 'Fehler: Spieler nicht gefunden.';
                  seerResultDisplayP.style.display = 'inline-block';
              }
         }


        // --- Confirm Night Action (mostly unchanged logic) ---
        function confirmNightAction() {
             if (gameState.currentNightActionStep < 0 || gameState.gameOver) return;

             const currentStepId = gameState.nightActionSequence[gameState.currentNightActionStep];
             const actionType = nightActionConfirmBtn.dataset.actionType || currentStepId;
             console.log(`Confirmed action for: ${actionType} (Step: ${currentStepId})`);

             let sleepPrompt = "";
             const roleDef = availableRoles.find(r => r.id === currentStepId || r.id === actionType); // Check actionType too for Hexe
             const roleName = roleDef ? roleDef.name : actionType; // Use actionType if button specific
             sleepPrompt = `GM: Sage '${roleName}, schläft wieder ein.'`;

             // Finalize selections based on currently highlighted items
             const selectedTargets = Array.from(targetPlayerListUl.querySelectorAll('.selected-target')).map(li => li.dataset.playerName);

             switch (actionType) { // Use actionType from button if specific (like hexe_poison)
                 case 'amor':
                     if (selectedTargets.length === 2) {
                         gameState.nightSelections.amorPair = selectedTargets;
                         gameState.loverPair = selectedTargets; // Set the main lover pair state
                         // Assign lover faction here
                         const lover1 = getPlayerData(selectedTargets[0]);
                         const lover2 = getPlayerData(selectedTargets[1]);
                         if(lover1) lover1.roleData.faction = 'Liebende'; // Update faction for win checks
                         if(lover2) lover2.roleData.faction = 'Liebende';
                         console.log("Amor chose:", selectedTargets);
                         // MODIFIED: Add GM note
                         const lover1Name = escapeHTML(selectedTargets[0]);
                         const lover2Name = escapeHTML(selectedTargets[1]);
                         sleepPrompt += `<p class="gm-note"><i>GM Info: Lasse das Paar (${lover1Name} & ${lover2Name}) sich nun heimlich erkennen.</i></p>`;
                     } else {
                           console.error("Amor confirmation error: Incorrect number of targets.");
                           sleepPrompt += `<p class="gm-note"><i>GM Info: Fehler bei Amor-Auswahl.</i></p>`;
                     }
                     break;
                 case 'leibwaechter':
                 case 'priester':
                     gameState.nightSelections.protectedThisNight = selectedTargets[0] || null; // Confirmed selection
                      console.log(`${actionType} confirmed protection:`, gameState.nightSelections.protectedThisNight);
                     break;
                 case 'dorfmatratze':
                     gameState.nightSelections.dorfmatratzeVisit = selectedTargets[0] || null;
                      console.log(`${actionType} confirmed visit:`, gameState.nightSelections.dorfmatratzeVisit);
                     break;
                 case 'werwolf':
                     gameState.nightSelections.werwolfTarget = selectedTargets[0] || null;
                      console.log(`${actionType} confirmed target:`, gameState.nightSelections.werwolfTarget);
                     break;
                 case 'vampir':
                      gameState.nightSelections.vampirTarget = selectedTargets[0] || null;
                       console.log(`${actionType} confirmed target:`, gameState.nightSelections.vampirTarget);
                     break;
                 case 'seherin':
                      gameState.nightSelections.seherinCheck = selectedTargets[0] || null;
                      console.log(`${actionType} confirmed check:`, gameState.nightSelections.seherinCheck);
                      // Seer result already displayed on selection
                      break;

                 case 'hexe_poison': // Specific confirmation for poison choice
                      gameState.nightSelections.poisonPotionTarget = selectedTargets[0] || null;
                      if (gameState.nightSelections.poisonPotionTarget && gameState.hexeHasPoisonPotion) {
                         // gameState.hexeHasPoisonPotion = false; // Mark potion used ON SKIP/DONE
                         console.log("Poison potion target chosen:", gameState.nightSelections.poisonPotionTarget);
                         // Hide selection list, go back to Hexe main controls (heal/poison choice) or skip/done
                         playerSelectionAreaDiv.style.display = 'none';
                         nightActionConfirmBtn.style.display = 'none';
                         nightActionSkipBtn.disabled = false; // Re-enable skip/done
                         nightActionSkipBtn.style.display = 'inline-block';
                          // Update used text for poison
                          const poisonUsedSpan = hexePoisonControlDiv.querySelector('.potion-used');
                          poisonUsedSpan.textContent = `Vergiftet ${escapeHTML(gameState.nightSelections.poisonPotionTarget)}.`;
                         return; // Don't advance night step yet, let Hexe finish turn via skip
                      } else {
                          // Error or no target selected, maybe reset?
                           const poisonUsedSpan = hexePoisonControlDiv.querySelector('.potion-used');
                           poisonUsedSpan.textContent = 'Gift nicht eingesetzt (Fehler).';
                      }
                     break;

                 default:
                     console.warn("Confirmation called on unexpected step/action:", actionType);
                      sleepPrompt = "Aktion bestätigt, fahre fort..."; // Generic fallback
             }

             // --- UI Cleanup & Advance ---
             gmPromptDiv.innerHTML = `<p>${sleepPrompt}</p>`;
             playerSelectionAreaDiv.style.display = 'none';
             hexeActionAreaDiv.style.display = 'none'; // Ensure Hexe area hidden
             nightActionConfirmBtn.style.display = 'none';
             nightActionSkipBtn.style.display = 'none';
             nightActionNextBtn.style.display = 'none'; // KEEP 'Next' button hidden here

             // --- MODIFIED: Directly advance step (Synchronous) ---
             advanceNightStep(); // Call directly, removed setTimeout
        }


        // --- Night Skip / Hexe Done ---
        function handleNightSkip(actionType) { // actionType from button dataset
            if (!actionType) return;
             const currentStepId = gameState.nightActionSequence[gameState.currentNightActionStep];
             const roleDef = availableRoles.find(r => r.id === currentStepId || r.id === 'hexe'); // Check hexe explicitly for hexe_skip
             const roleName = roleDef ? roleDef.name : currentStepId;

             console.log(`Skip/Done button clicked for: ${actionType}`);

            if (actionType === 'hexe_skip') {
                 // Finalize Hexe potion usage
                 if (gameState.nightSelections.healPotionUsedOn && gameState.hexeHasHealPotion) {
                     gameState.hexeHasHealPotion = false; // Mark heal used
                     console.log("Heal potion confirmed used (via skip/done) on:", gameState.nightSelections.healPotionUsedOn);
                 }
                 if (gameState.nightSelections.poisonPotionTarget && gameState.hexeHasPoisonPotion) {
                     gameState.hexeHasPoisonPotion = false; // Mark poison used
                     console.log("Poison potion confirmed used (via skip/done) on:", gameState.nightSelections.poisonPotionTarget);
                 } else if (gameState.hexeHasPoisonPotion && !gameState.nightSelections.poisonPotionTarget) {
                     // If potion was available but no target selected (e.g., chose 'No' or confirmed 0 targets)
                     console.log("Poison potion confirmed NOT used (via skip/done).");
                 }
                 // Hexe sleeps
                 gmPromptDiv.innerHTML = `<p>GM: Sage '${roleName}, schläft wieder ein.'</p>`;

            } else if (actionType.endsWith('_skip')) {
                // Optional role skipped (Leibwächter, Priester, etc.)
                const baseAction = actionType.replace('_skip', '');
                 const skippedRoleDef = availableRoles.find(r => r.id === baseAction);
                 const skippedRoleName = skippedRoleDef ? skippedRoleDef.name : baseAction;

                console.log(`${skippedRoleName} chose to skip their action.`);
                 // Clear any tentative selection for that role
                 switch(baseAction) {
                      case 'leibwaechter':
                      case 'priester': gameState.nightSelections.protectedThisNight = null; break;
                      case 'dorfmatratze': gameState.nightSelections.dorfmatratzeVisit = null; break;
                      case 'seherin': gameState.nightSelections.seherinCheck = null; break;
                 }
                gmPromptDiv.innerHTML = `<p>GM: Sage '${skippedRoleName}, schläft wieder ein.'</p>`;
            } else {
                console.warn("Unhandled skip action:", actionType);
                return; // Don't advance if unknown action
            }

            // --- UI Cleanup & Advance ---
             playerSelectionAreaDiv.style.display = 'none';
             hexeActionAreaDiv.style.display = 'none';
             nightActionConfirmBtn.style.display = 'none';
             nightActionSkipBtn.style.display = 'none';
             nightActionNextBtn.style.display = 'none'; // KEEP 'Next' button hidden here

             // --- MODIFIED: Directly advance step (Synchronous) ---
             advanceNightStep(); // Call directly, removed setTimeout
        }

        // --- End Night Actions (mostly unchanged logic) ---
        function endNightActions() {
             console.log("Ending Night Actions.");
             gameState.currentNightActionStep = -1; // Mark sequence finished

             // Calculate deaths first, as this might trigger pending AKW/Jaeger flags
             calculateAndApplyNightDeaths();

             // Check for pending AKW selection triggered during the night
             if (gameState.pendingAkwSelection && gameState.akwVictim) {
                 console.log("Handling pending AKW selection before showing night results.");
                 const victimName = gameState.akwVictim; // Store name before state change
                 gameState.gamePhaseState = 'AKW_SELECTION'; // Set state for UI
                 setupAkwSelectionUI(victimName); // Setup UI for GM selection
                 updatePhaseDisplayAndControls(); // Update UI
                 // STOP here - wait for GM selection via handleDayActionConfirm('akw')
                 return;
             }

             // If no pending AKW, proceed to show results and prepare for day
             gameState.gamePhaseState = 'NIGHT_RESULTS'; // Move to results phase
             displayNightResults(); // Prepare results display based on calculated deaths/saves
             renderGmPlayerList(); // Update list with any deaths/turns/role changes
             updatePhaseDisplayAndControls(); // Show results and 'Start Day' button

             // Check win conditions after night fully resolved (unless AKW is pending)
              if (!gameState.pendingAkwSelection) {
                  checkWinConditions();
                  // If game over, updatePhaseDisplayAndControls called inside checkWin->endGame
              }
        }

        // --- Death Logic (mostly unchanged logic) ---
        // ... (applyDeath, checkLoverDeath, triggerJaegerShot, triggerAKWEffect) ...
          // Central function to mark a player as dead and trigger effects
        function applyDeath(playerName, cause, triggerSourcePlayer = null) {
            console.log(`Applying death to ${playerName} due to ${cause}`);
            const player = getPlayerData(playerName);

            if (!player || player.status !== 'Lebend') {
                console.log(`${playerName} not found or not currently Lebend.`);
                return false; // Indicate no death applied this time
            }

            // --- Log if player was bitten ---
            if (player.isBitten) {
                console.log(`INFO: ${playerName} was bitten by a Vampire before dying from ${cause}.`);
                // deathDetails.wasBitten = true; // Optional tracking
            }

            // --- Mark as Dead/Geist ---
            const originalRole = player.roleData;
            if (originalRole.id === 'geist') { // Check original role for Geist
                player.status = 'Geist';
            } else {
                player.status = 'Tot';
            }
            // If status changed to Geist, ensure original role is stored
            if (player.status === 'Geist' && !player.originalRoleData) player.originalRoleData = originalRole;


             // --- Reset Bite Status ---
             player.isBitten = false;

            // --- Store Death Details (for display/tracking) ---
            const deathDetails = { name: player.name, role: originalRole.name, cause: cause };
            if (cause === 'lynch') {
                 gameState.lynchTarget = player.name; // Keep track of who was targeted
                 gameState.lynchVictimRole = originalRole.name; // Store role at time of lynch
                 gameState.dailyDeaths.push(deathDetails);
            } else if (cause === 'werwolf') {
                 gameState.nightResults.killedPlayerName = player.name;
                 gameState.nightResults.killedPlayerRole = originalRole.name;
            } else if (cause === 'hexe_poison') {
                 gameState.nightResults.poisonedPlayerName = player.name;
                 gameState.nightResults.poisonedPlayerRole = originalRole.name;
            } else if (cause === 'vampir_bite') { // Delayed bite death
                 gameState.dailyDeaths.push(deathDetails); // Add to daily deaths display
                 console.log(`🩸 ${playerName} succumbed to the Vampire bite.`);
            } else if (cause === 'jaeger_shot') {
                 gameState.diedFromHunter = player.name; // Who was shot
                 gameState.dailyDeaths.push(deathDetails);
            } else if (cause === 'akw_effect') {
                 if (!gameState.diedFromAKW.includes(player.name)) gameState.diedFromAKW.push(player.name);
                 gameState.dailyDeaths.push(deathDetails);
            } else if (cause === 'lover_heartbreak') {
                 gameState.diedWithLover = player.name; // Who died of heartbreak
                 console.log(`💔 AMOR COUPLE DEATH: ${playerName} died of heartbreak.`);
                  // Add to appropriate death list based on when it happens
                 if (gameState.currentPhase === 'Tag' || ['JAEGER_SHOT', 'AKW_SELECTION', 'DAY_LYNCH_CONFIRM', 'DAY_REINIGUNGSKRAFT', 'NIGHT_RESULTS'].includes(gameState.gamePhaseState)) {
                     gameState.dailyDeaths.push(deathDetails);
                 }
                 // Night deaths are handled implicitly via cascade
            } else if (cause === 'dorfmatratze_visit') {
                 // Store the pair who died for better reporting in displayNightResults
                 if (!gameState.nightResults.dorfmatratzeDeath.includes(player.name)) {
                    gameState.nightResults.dorfmatratzeDeath.push(player.name);
                 }
                 // Don't push to diedFromDorfmatratze here, handled by nightResults structure
            }

            renderGmPlayerList(); // Update GM list immediately

            // --- Trigger Cascading Effects ---
            let requiresFurtherAction = false;
            const loverDied = checkLoverDeath(player.name, cause); // This calls applyDeath recursively if needed
             if (loverDied) requiresFurtherAction = true;

            // Only trigger Jaeger/AKW if the cause wasn't heartbreak itself // << REMOVED THIS CONDITION
            // if (cause !== 'lover_heartbreak') { // << REMOVED
                if (originalRole.id === 'jaeger' && !gameState.pendingHunterShot && player.status !== 'Geist') { // Don't trigger if player becomes Geist
                    // Check if the game state allows immediate trigger or needs delay
                    if (gameState.currentPhase === 'Nacht' || gameState.gamePhaseState === 'NIGHT_RESULTS') {
                        gameState.pendingHunterShot = true;
                        gameState.hunterVictim = playerName;
                         requiresFurtherAction = true; // Mark action pending for start of day
                         console.log("Jaeger shot pending for start of day.");
                    } else {
                        // Day time or immediate effect phase
                        triggerJaegerShot(playerName);
                        requiresFurtherAction = true; // Jaeger UI is now active
                    }
                }
                else if (originalRole.id === 'akw' && !gameState.pendingAkwSelection && player.status !== 'Geist') {
                     if (gameState.currentPhase === 'Nacht' || gameState.gamePhaseState === 'NIGHT_RESULTS') {
                         gameState.pendingAkwSelection = true;
                         gameState.akwVictim = playerName;
                         requiresFurtherAction = true; // Mark action pending for start of day
                         console.log("AKW selection pending for start of day.");
                         // If triggered during night calculation, the endNightActions check will catch it
                     } else {
                         triggerAKWEffect(playerName);
                         requiresFurtherAction = true; // AKW UI is now active
                     }
                }
            // } // << REMOVED

            // Win conditions checked after recursion/effects resolve or after pending actions handled
            if (!requiresFurtherAction && !gameState.pendingHunterShot && !gameState.pendingAkwSelection) {
                 // Check win conditions immediately only if no further actions are required
                 checkWinConditions();
             } else {
                 console.log("Further actions required or pending (Lover/Jaeger/AKW), delaying win condition check.");
             }

            return true; // Indicate death was applied
        }

        function checkLoverDeath(deadPlayerName, originalCause) {
            // Prevent check if the death was already heartbreak to avoid infinite loops
            if (originalCause === 'lover_heartbreak') return false;

            if (gameState.loverPair.includes(deadPlayerName)) {
                const otherLoverName = gameState.loverPair.find(name => name !== deadPlayerName);
                if (otherLoverName) {
                    const otherLover = getPlayerData(otherLoverName);
                    if (otherLover && otherLover.status === 'Lebend') {
                        console.log(`Triggering heartbreak death for ${otherLoverName} due to ${deadPlayerName}'s death.`);
                        // Apply death recursively, return true if this *second* death happened
                        return applyDeath(otherLoverName, 'lover_heartbreak');
                    }
                }
            }
            return false; // No lover died from this specific death event
        }

        function triggerJaegerShot(jaegerName) {
            console.log(`Jaeger ${jaegerName} died, needs to shoot.`);
            if (gameState.gameOver) return; // Don't trigger if game already ended

            // Ensure any pending status is cleared if triggering immediately
            gameState.pendingHunterShot = false;
            gameState.hunterVictim = jaegerName;
            gameState.gamePhaseState = 'JAEGER_SHOT'; // Change state
            setupJaegerShotUI(jaegerName); // Setup the UI immediately
            updatePhaseDisplayAndControls(); // Update UI to show Jaeger area
        }

        function triggerAKWEffect(akwPlayerName) {
            console.log(`AKW ${akwPlayerName} died, neighbors need to be selected.`);
             if (gameState.gameOver) return; // Don't trigger if game already ended

             gameState.pendingAkwSelection = false; // Clear pending if triggering now
            gameState.akwVictim = akwPlayerName;
            gameState.diedFromAKW = []; // Reset list for this trigger
            gameState.gamePhaseState = 'AKW_SELECTION'; // Change state
            setupAkwSelectionUI(akwPlayerName); // Setup the UI immediately
            updatePhaseDisplayAndControls(); // Update UI to show AKW area
        }


        // --- Night Death Calculation & Results (mostly unchanged logic) ---
        // ... (calculateAndApplyNightDeaths, displayNightResults) ...
          function calculateAndApplyNightDeaths() {
            console.log("Calculating night deaths...");
            // Reset results structure for this night
             gameState.nightResults = { killedPlayerName: null, killedPlayerRole: null, poisonedPlayerName: null, poisonedPlayerRole: null, bittenPlayerName: null, bittenPlayerRole: null, holyWaterKillName: null, holyWaterKillRole: null, dorfmatratzeDeath: [], savedByBodyguard: null, savedByPriest: null, savedByHexe: null, savedByMatratze: null, turnedVerfluchter: null };
             gameState.diedWithLover = null; // Reset lover death flag for night results display
             gameState.diedFromDorfmatratze = []; // Reset dorfmatratze death display

            const { werwolfTarget, protectedThisNight, healPotionUsedOn, poisonPotionTarget, dorfmatratzeVisit, vampirTarget } = gameState.nightSelections;

            let actualDeathsThisNight = []; // Track who ACTUALLY died to prevent double-counting effects
            let matratzeDiesWithVisitor = false; // Flag if matratze dies visiting target
            let matratzeTargetedAtHome = false; // Flag if matratze targeted while away

             // --- Pre-calculate Matratze state ---
             const matratze = gameState.players.find(p => p.roleData.id === 'dorfmatratze' && p.status === 'Lebend');
             const matratzeVisitingPlayer = matratze ? gameState.nightSelections.dorfmatratzeVisit : null; // Who did matratze select?
             const matratzeIsVisiting = matratze && matratzeVisitingPlayer; // Is matratze visiting anyone?

             // --- Protection Application ---
             if (protectedThisNight) {
                 const protectedPlayer = getPlayerData(protectedThisNight);
                 if (protectedPlayer) {
                      protectedPlayer.isProtected = true;
                      console.log(`${protectedThisNight} is marked as protected.`);
                 }
             }
             if (matratze) {
                 matratze.visitedPlayer = matratzeVisitingPlayer; // Can be null if didn't visit
                 if(matratze.visitedPlayer) console.log(`Matratze ${matratze.name} visiting ${matratze.visitedPlayer}`);
             }


            // --- 1. Hexe Poison ---
            if (poisonPotionTarget && !gameState.gameOver) { // Check game over
                 const victim = getPlayerData(poisonPotionTarget);
                 if (victim && victim.status === 'Lebend') {
                     if (matratzeIsVisiting && poisonPotionTarget === matratzeVisitingPlayer) {
                         matratzeDiesWithVisitor = true; // Mark Matratze to die
                     }
                     if (matratzeIsVisiting && poisonPotionTarget === matratze.name) {
                         matratzeTargetedAtHome = true; // Mark as targeted at home (will survive)
                         gameState.nightResults.savedByMatratze = matratze.name; // Log save immediately
                     }

                     if (!matratzeTargetedAtHome || poisonPotionTarget !== matratze.name) {
                        if (applyDeath(poisonPotionTarget, 'hexe_poison')) {
                            actualDeathsThisNight.push(poisonPotionTarget);
                        }
                        if (gameState.gameOver) return; // Stop if game ended during applyDeath
                     }
                 }
            }

            // --- 2. Werwolf Attack ---
            if (werwolfTarget && !gameState.gameOver) { // Check game over
                const targetPlayer = getPlayerData(werwolfTarget);
                if (targetPlayer && targetPlayer.status === 'Lebend') {
                    let saved = false;
                    wolfAttackSuccessful = true;

                    if (targetPlayer.roleData.id === 'vampir') saved = true;
                    if (!saved && targetPlayer.isProtected) {
                        saved = true;
                        // ... log save ...
                    }
                    if (!saved && werwolfTarget === healPotionUsedOn) {
                        saved = true;
                        // ... log save ...
                    }

                    let matratzeDiesVisitingWolfTarget = false;
                    if (!saved && matratzeIsVisiting && matratzeVisitingPlayer === werwolfTarget) {
                        matratzeDiesVisitingWolfTarget = true;
                    }
                     if (!saved && matratzeIsVisiting && werwolfTarget === matratze.name) {
                         matratzeTargetedAtHome = true;
                         gameState.nightResults.savedByMatratze = matratze.name;
                         saved = true;
                     }

                    if (!saved && targetPlayer.roleData.id === 'verfluchter') {
                         saved = true;
                         // ... transform player ...
                         gameState.nightResults.turnedVerfluchter = werwolfTarget;
                         wolfTargetKilled = false;
                    }

                    if (!saved) {
                         const currentTargetStatus = getPlayerData(werwolfTarget)?.status;
                         if (currentTargetStatus === 'Lebend') {
                             if (!actualDeathsThisNight.includes(werwolfTarget)) {
                                if (applyDeath(werwolfTarget, 'werwolf')) {
                                    actualDeathsThisNight.push(werwolfTarget);
                                    wolfTargetKilled = true;
                                }
                                if (gameState.gameOver) return; // Stop if game ended during applyDeath
                             }
                         }
                    }

                    if (matratzeDiesVisitingWolfTarget && matratze && !gameState.gameOver) { // Check game over
                         const matratzeStatus = getPlayerData(matratze.name)?.status;
                         if (matratzeStatus === 'Lebend' && !actualDeathsThisNight.includes(matratze.name)) {
                             if(applyDeath(matratze.name, 'dorfmatratze_visit')) {
                                actualDeathsThisNight.push(matratze.name);
                                // ... record dorfmatratzeDeath ...
                            }
                            if (gameState.gameOver) return; // Stop if game ended during applyDeath
                         }
                     }

                } else if (targetPlayer) { /* log target not alive */ }
                 else { /* log target not found */ }
            }


             // --- 3. Vampir Attack ---
             if (vampirTarget && !gameState.gameOver) { // Check game over
                 const targetPlayer = getPlayerData(vampirTarget);
                 if (targetPlayer && targetPlayer.status === 'Lebend') {
                      let saved = false;
                      if (targetPlayer.isProtected) {
                            saved = true;
                            // ... log save ...
                       }
                      if (!saved && matratzeIsVisiting && vampirTarget === matratze.name) {
                           matratzeTargetedAtHome = true;
                           gameState.nightResults.savedByMatratze = matratze.name;
                           saved = true;
                      }
                      if (!saved && targetPlayer.roleData.id !== 'vampir') {
                           targetPlayer.isBitten = true;
                           gameState.nightResults.bittenPlayerName = vampirTarget;
                           gameState.nightResults.bittenPlayerRole = targetPlayer.roleData.name;
                      }
                 }
             }

            // --- Matratze deaths visiting poisoned/wolf target already handled above ---

            console.log("Night death calculation complete. Deaths this night:", actualDeathsThisNight);
            // No explicit win check needed here, applyDeath handles cascade and win checks.
        }

         function displayNightResults() {
              dayResultsDisplayDiv.innerHTML = '<h4>Ergebnisse der Nacht</h4>'; // Consistent H4 styling
              let resultsFound = false;
              let messages = []; // Collect messages to display
              let gmNotes = []; // Collect GM-specific notes

               // Saves First
              if (gameState.nightResults.savedByBodyguard) { messages.push(`🛡️ Durch Leibwächter gerettet: ${escapeHTML(gameState.nightResults.savedByBodyguard)}`); resultsFound = true; }
              if (gameState.nightResults.savedByPriest) { messages.push(`🙏 Durch Priester gerettet: ${escapeHTML(gameState.nightResults.savedByPriest)}`); resultsFound = true; }
              if (gameState.nightResults.savedByHexe) { messages.push(`💚 Durch Hexe gerettet: ${escapeHTML(gameState.nightResults.savedByHexe)}`); resultsFound = true; }
              if (gameState.nightResults.savedByMatratze) { messages.push(`🏠 Dorfmatratze (${escapeHTML(gameState.nightResults.savedByMatratze)}) überlebte Angriff zu Hause (war zu Besuch).`); resultsFound = true; }

              // Transformations
              if (gameState.nightResults.turnedVerfluchter) {
                   messages.push(`🐺 ${escapeHTML(gameState.nightResults.turnedVerfluchter)} (Verfl.) wurde zum Werwolf verwandelt!`);
                   // NEW: Add GM Note for Verfluchter
                   gmNotes.push(`<i>GM Info: ${escapeHTML(gameState.nightResults.turnedVerfluchter)} wurde verwandelt! Heimlich informieren.</i>`);
                   resultsFound = true;
              }

              // Deaths
              if (gameState.nightResults.killedPlayerName) {
                   const role = gameState.nightResults.killedPlayerRole || '?';
                   messages.push(`💀 Von Werwölfen getötet: ${escapeHTML(gameState.nightResults.killedPlayerName)} (${escapeHTML(role)})`);
                   resultsFound = true;
               }
              if (gameState.nightResults.poisonedPlayerName) {
                    const role = gameState.nightResults.poisonedPlayerRole || '?';
                    messages.push(`☠️ Durch Hexe vergiftet: ${escapeHTML(gameState.nightResults.poisonedPlayerName)} (${escapeHTML(role)})`);
                    resultsFound = true;
                }

               // Matratze Death Display - IMPROVED LOGIC
               if (gameState.nightResults.dorfmatratzeDeath.length > 0) {
                    const deadNames = gameState.nightResults.dorfmatratzeDeath;
                    const matratzeData = gameState.players.find(p => p.originalRoleData?.id === 'dorfmatratze' && deadNames.includes(p.name));
                    const matratzeName = matratzeData?.name;
                    const visitedName = deadNames.find(name => name !== matratzeName); // Find the other person who died
                    const visitedData = visitedName ? getPlayerData(visitedName) : null;
                    const visitedRole = visitedData?.originalRoleData?.name || visitedData?.roleData?.name || '?';

                    let message = '';
                    let gmNoteDetail = '';

                    if (matratzeName && visitedName) {
                        // Both Matratze and visited player died
                        message = `💔 ${escapeHTML(matratzeName)} (Matratze) und ${escapeHTML(visitedName)} (${escapeHTML(visitedRole)}) starben zusammen!`;
                        gmNoteDetail = `Matratze (${escapeHTML(matratzeName)}) besuchte ${escapeHTML(visitedName)}. ${escapeHTML(visitedName)} wurde angegriffen, daher starben beide.`;
                    } else if (matratzeName && deadNames.length === 1) {
                        // Should not happen based on game rules (Matratze dies *with* attacked visitor), but log defensively
                        message = `❓ ${escapeHTML(matratzeName)} (Matratze) starb. (Ungewöhnlich, besuchte Person überlebte?)`;
                        gmNoteDetail = `Matratze (${escapeHTML(matratzeName)}) starb, aber die besuchte Person (${escapeHTML(gameState.nightSelections.dorfmatratzeVisit || 'unbekannt')}) überlebte. Prüfe Logik/Regeln.`;
                    } else if (visitedName && deadNames.length === 1) {
                         // Should not happen based on game rules (Matratze dies *with* attacked visitor), but log defensively
                         message = `❓ ${escapeHTML(visitedName)} (${escapeHTML(visitedRole)}) starb, als er/sie von der Matratze besucht wurde. (Ungewöhnlich, Matratze überlebte?)`;
                         gmNoteDetail = `${escapeHTML(visitedName)} wurde angegriffen und starb, aber die besuchende Matratze (${escapeHTML(gameState.players.find(p=>p.roleData.id==='dorfmatratze')?.name || 'unbekannt')}) überlebte. Prüfe Logik/Regeln.`;
                     } else {
                         // Fallback for unexpected state
                         message = `❓ Mehrere Spieler starben im Zusammenhang mit Matratzenbesuch: ${deadNames.map(escapeHTML).join(', ')}`;
                         gmNoteDetail = `Unklare Umstände beim Matratzenbesuch führten zum Tod von: ${deadNames.map(escapeHTML).join(', ')}. Prüfe Logik.`;
                    }
                    messages.push(message);
                    gmNotes.push(`<i>GM Info (Matratze): ${gmNoteDetail}</i>`);
                    resultsFound = true;
               }


               // Lover Death Display
               if (gameState.diedWithLover) {
                    const deadLoverData = gameState.players.find(p => p.name === gameState.diedWithLover); // Get data before potential purge
                    const deadLoverRole = deadLoverData?.originalRoleData?.name || deadLoverData?.roleData?.name || '?';
                    const otherLover = gameState.loverPair.find(name => name !== gameState.diedWithLover);
                    messages.push(`<span class="lover-death">💔 ${escapeHTML(gameState.diedWithLover)} (${escapeHTML(deadLoverRole)}) starb aus Kummer um ${escapeHTML(otherLover || 'Liebste/n')}!</span>`);
                    // NEW: Add GM Note for Lover Death
                    gmNotes.push(`<i>GM Info (Liebeskummer): ${escapeHTML(gameState.diedWithLover)} starb, weil ${escapeHTML(otherLover || 'der/die andere Liebende')} gestorben ist. Beide Tode ansagen.</i>`);
                    resultsFound = true;
                }


               // Bites (Delayed Effect)
               if (gameState.nightResults.bittenPlayerName) {
                    const role = gameState.nightResults.bittenPlayerRole || '?';
                    messages.push(`🩸 Von Vampiren gebissen: ${escapeHTML(gameState.nightResults.bittenPlayerName)} (${escapeHTML(role)}) (stirbt am Ende des Tages)`); // Updated timing text
                    resultsFound = true;
                }

              // If nothing significant happened
              if (!resultsFound) {
                   messages.push(`🌙 Eine ruhige Nacht. Nichts ist passiert.`);
              }

              dayResultsDisplayDiv.innerHTML += messages.map(msg => `<p>${msg}</p>`).join('');
              // NEW: Append GM notes if any
              if (gmNotes.length > 0) {
                  dayResultsDisplayDiv.innerHTML += gmNotes.map(note => `<p class="gm-note">${note}</p>`).join('');
              }
              dayResultsDisplayDiv.style.display = 'block';
         }

        // --- Day Phase Logic (mostly unchanged logic) ---
        // ... (startDayPhase, startVotingProcess) ...
          function startDayPhase() {
            console.log("Starting Day Phase...");
             // Check if game ended overnight (e.g. lover death during night calculations)
              if (checkWinConditions()) {
                  console.log("Game ended during overnight checks/calculations.");
                  // Pass context to endGame for specific message
                  endGame('overnight');
                  return;
              }

             // Check if starting from valid states
             if (!['NIGHT_RESULTS', 'AKW_SELECTION', 'JAEGER_SHOT'].includes(gameState.gamePhaseState)) {
                 console.warn("Cannot start day phase, invalid state:", gameState.gamePhaseState);
                 return;
             }

             // Reset daily death list for the new day display
              gameState.dailyDeaths = [];
              gameState.diedFromHunter = null;
              gameState.diedFromAKW = [];
              // Reset day-specific choices
              gameState.blumenkindSavedPlayer = null;
              gameState.lynchTarget = null;
              gameState.lynchVictimRole = null;
              // Don't reset hideLynchRole here, it's reset at start of night


             // --- Check for Delayed Jäger Shot ---
              if (gameState.pendingHunterShot && gameState.hunterVictim) {
                  console.log("Triggering delayed Jaeger shot UI at start of day.");
                  const victimName = gameState.hunterVictim; // Store before state change
                  gameState.pendingHunterShot = false; // Clear flag as we are handling it now
                  triggerJaegerShot(victimName); // Setup UI, sets state to JAEGER_SHOT
                  // Don't proceed further, wait for Jaeger confirmation
                  return;
              }
               // --- Check for Delayed AKW Effect ---
               // AKW triggered during night calcs is handled *before* night results are shown.
               // So we don't need to check pendingAkwSelection here.

             // --- Transition to Discussion ---
             console.log("Transitioning to Day Discussion.");
             gameState.currentPhase = 'Tag';
             gameState.gamePhaseState = 'DAY_DISCUSSION';
             startDayTimer();


             // Clear night selections (except permanent ones like lovers)
             gameState.nightSelections = {
                 ...gameState.nightSelections, // Keep lovers etc.
                 werwolfTarget: null, seherinCheck: null, protectedThisNight: null,
                 healPotionUsedOn: null, poisonPotionTarget: null,
                 dorfmatratzeVisit: null, vampirTarget: null
             };


             renderGmPlayerList(); // Update list (e.g. Verfluchter role change)
             updatePhaseDisplayAndControls(); // Update UI

             // Final win condition check before discussion starts
             checkWinConditions(); // If game ends, UI updates inside endGame
         }

         function startVotingProcess() {
              if (gameState.gameOver || gameState.gamePhaseState !== 'DAY_DISCUSSION') return;
              console.log("Starting voting process...");
              // REMOVED: stopDayTimer(); Timer continues or restarts for votes

              // REMOVED: Applying bite deaths here, moved to finishDayPhase
              // const biteDeathOccurred = applyDelayedBiteDeaths(); // This checks win conditions internally
              // if (gameState.gameOver) { ... }

              // Determine next step based on phase number and roles
              if (gameState.phaseNumber === 1 && !gameState.buergermeister) {
                  // --- Day 1: Mayor Vote First ---
                  console.log("Day 1: Proceeding to Mayor Vote.");
                  gameState.gamePhaseState = 'DAY_MAYOR_VOTE';
                  setupMayorVoteUI();
                  startDayTimer(); // NEW: Start/Restart timer for Mayor vote
              } else {
                  // --- Day > 1 OR Day 1 After Mayor Vote: Normal Lynch Process ---
                   if (gameState.phaseNumber > 1) console.log("Day > 1: Proceeding to Lynch Process.");
                   else console.log("Day 1 (Post-Mayor): Proceeding to Lynch Process.");

                   // Check Blumenkind Save -> Lynch Vote
                   stopDayTimer(); // NEW: Stop timer before Blumenkind choice (if any)
                  if (!gameState.blumenkindUsedSave && isRoleActive('blumenkind')) {
                      gameState.gamePhaseState = 'DAY_BLUMENKIND_SAVE';
                      setupBlumenkindSaveUI();
                  } else {
                      gameState.gamePhaseState = 'DAY_LYNCH_VOTE';
                      setupLynchVoteUI();
                      startDayTimer(); // NEW: Start/Restart timer for Lynch vote
                  }
              }
              updatePhaseDisplayAndControls();
         }

        // --- Day Action UI Setup Functions (mostly unchanged logic) ---
        // ... (setupMayorVoteUI, setupBlumenkindSaveUI, setupLynchVoteUI, setupLynchConfirmUI, setupReinigungskraftUI, setupJaegerShotUI, setupAkwSelectionUI) ...
          function setupMayorVoteUI() {
            dayActionTitleH4.textContent = "Bürgermeisterwahl";
            dayActionPromptP.textContent = "Das Dorf wählt einen Bürgermeister. Wähle den Spieler mit den meisten Stimmen aus.";
            renderDayActionTargetList('mayor');
            dayActionConfirmBtn.textContent = "Bürgermeister bestätigen";
            dayActionConfirmBtn.disabled = true;
            dayActionConfirmBtn.style.display = 'inline-block';
            dayActionConfirmBtn.dataset.actionType = 'mayor'; // Set action type
            dayActionSkipBtn.style.display = 'none'; // No skipping mayor vote
            reinigungskraftChoiceAreaDiv.style.display = 'none';
            blumenkindSaveAreaDiv.style.display = 'none';
            startDayTimer(); // <<< Start/Restart timer when vote UI is set up
        }

        function setupBlumenkindSaveUI() {
             dayActionTitleH4.textContent = "Blumenkind Rettung";
             dayActionPromptP.textContent = `Blumenkind (${gameState.blumenkindUsedSave ? 'Fähigkeit benutzt' : 'Fähigkeit verfügbar'}) kann einmalig jemanden vor der Abstimmung retten.`;
             dayActionTargetListUl.innerHTML = ''; // No target list needed here, just Yes/No
             blumenkindSaveAreaDiv.style.display = 'block'; // Show Yes/No buttons
             const yesBtn = blumenkindSaveAreaDiv.querySelector('button[data-choice="yes"]');
             const noBtn = blumenkindSaveAreaDiv.querySelector('button[data-choice="no"]');
              if (gameState.blumenkindUsedSave) { // Disable if used
                 if(yesBtn) yesBtn.disabled = true;
                 if(noBtn) noBtn.disabled = true;
              } else {
                 if(yesBtn) yesBtn.disabled = false;
                 if(noBtn) noBtn.disabled = false;
              }
             dayActionConfirmBtn.style.display = 'none';
             dayActionConfirmBtn.dataset.actionType = ''; // Clear action type
             dayActionSkipBtn.style.display = 'none';
             reinigungskraftChoiceAreaDiv.style.display = 'none';
        }

        function setupLynchVoteUI() {
            dayActionTitleH4.textContent = "Lynch Abstimmung";
            dayActionPromptP.textContent = "Das Dorf stimmt ab, wer gelyncht werden soll. Wähle den Spieler mit den meisten Stimmen aus.";
            renderDayActionTargetList('lynch');
            dayActionConfirmBtn.textContent = "Lynchziel bestätigen";
            dayActionConfirmBtn.disabled = true;
            dayActionConfirmBtn.style.display = 'inline-block';
            dayActionConfirmBtn.dataset.actionType = 'lynch'; // Set action type
            dayActionSkipBtn.style.display = 'none'; // No skipping lynch vote usually
             reinigungskraftChoiceAreaDiv.style.display = 'none';
             blumenkindSaveAreaDiv.style.display = 'none';
             startDayTimer(); // <<< Start/Restart timer when vote UI is set up
        }

        function setupLynchConfirmUI(targetName) {
             const targetData = getPlayerData(targetName);
             // Determine role display based on potential hiding
             let roleDisplay = '(Rolle unbekannt)';
             if (targetData) {
                  roleDisplay = `(Rolle: ${escapeHTML(targetData.roleData.name)})`;
             }

             dayActionTitleH4.textContent = "Lynch Bestätigung";
             dayActionPromptP.innerHTML = `Soll <strong>${escapeHTML(targetName)}</strong> ${roleDisplay} wirklich gelyncht werden?`;
             dayActionTargetListUl.innerHTML = ''; // No list needed
             dayActionConfirmBtn.textContent = "Lynchen bestätigen";
             dayActionConfirmBtn.disabled = false; // Enable confirm
             dayActionConfirmBtn.style.display = 'inline-block';
             dayActionConfirmBtn.dataset.actionType = 'lynch_confirm'; // Set action type
             dayActionSkipBtn.textContent = "Abbrechen"; // Use skip as cancel
             dayActionSkipBtn.style.display = 'inline-block';
             dayActionSkipBtn.dataset.actionType = 'lynch_cancel'; // Set action type for skip
             reinigungskraftChoiceAreaDiv.style.display = 'none';
             blumenkindSaveAreaDiv.style.display = 'none';
        }

         function setupReinigungskraftUI() {
             dayActionTitleH4.textContent = "Reinigungskraft";
             const lynchTargetName = gameState.lynchTarget || 'Unbekannt';
             const lynchTargetRole = gameState.lynchVictimRole || 'Unbekannt';
             dayActionPromptP.textContent = `Reinigungskraft (${gameState.reinigungskraftUsedClean ? 'Fähigkeit benutzt' : 'Fähigkeit verfügbar'}) kann einmalig entscheiden, ob die Rolle von ${escapeHTML(lynchTargetName)} (${escapeHTML(lynchTargetRole)}) öffentlich gezeigt wird.`;
             dayActionTargetListUl.innerHTML = '';
             reinigungskraftChoiceAreaDiv.style.display = 'block'; // Show Yes/No buttons
             const yesBtn = reinigungskraftChoiceAreaDiv.querySelector('button[data-choice="yes"]'); // Yes = Hide Role
             const noBtn = reinigungskraftChoiceAreaDiv.querySelector('button[data-choice="no"]');  // No = Reveal Role
              if (gameState.reinigungskraftUsedClean) { // Disable if used
                  if(yesBtn) yesBtn.disabled = true;
                  if(noBtn) noBtn.disabled = true;
              } else {
                  if(yesBtn) yesBtn.disabled = false;
                  if(noBtn) noBtn.disabled = false;
              }
             dayActionConfirmBtn.style.display = 'none';
             dayActionConfirmBtn.dataset.actionType = ''; // Clear action type
             dayActionSkipBtn.style.display = 'none';
             blumenkindSaveAreaDiv.style.display = 'none';
         }

         function setupJaegerShotUI(jaegerName) {
              dayActionTitleH4.textContent = "Jäger Schuss";
              dayActionPromptP.textContent = `Der Jäger (${escapeHTML(jaegerName)}) wurde getötet und muss einen letzten Schuss abgeben. Wähle das Ziel:`;
              renderDayActionTargetList('jaeger', jaegerName); // Exclude the Jaeger themself
              dayActionConfirmBtn.textContent = "Schuss bestätigen";
              dayActionConfirmBtn.disabled = true;
              dayActionConfirmBtn.style.display = 'inline-block';
              dayActionConfirmBtn.dataset.actionType = 'jaeger'; // Set action type
              dayActionSkipBtn.style.display = 'none'; // Jaeger MUST shoot
              reinigungskraftChoiceAreaDiv.style.display = 'none';
              blumenkindSaveAreaDiv.style.display = 'none';
         }

         function setupAkwSelectionUI(akwPlayerName) {
              dayActionTitleH4.textContent = "AKW Effekt";
              dayActionPromptP.textContent = `Das AKW (${escapeHTML(akwPlayerName)}) ist explodiert! Wähle bis zu zwei lebende Spieler aus, die ebenfalls sterben sollen (GM entscheidet).`;
              renderDayActionTargetList('akw', akwPlayerName, 2); // Allow up to 2 selections, exclude AKW
              dayActionConfirmBtn.textContent = "Nachbarn auswählen";
              // Allow confirming with 0 selections for AKW
              dayActionConfirmBtn.disabled = false;
              dayActionConfirmBtn.style.display = 'inline-block';
              dayActionConfirmBtn.dataset.actionType = 'akw'; // Set action type
              dayActionSkipBtn.style.display = 'none'; // No skipping selection
              reinigungskraftChoiceAreaDiv.style.display = 'none';
              blumenkindSaveAreaDiv.style.display = 'none';
         }


        // --- Day Action Target List & Handling (mostly unchanged logic) ---
        // ... (renderDayActionTargetList, handleDayActionSelection) ...
        function renderDayActionTargetList(actionType, excludePlayer = null, maxSelections = 1) {
             dayActionTargetListUl.innerHTML = '';
             let eligibleTargets = getLivingPlayers();

             if (excludePlayer) {
                 eligibleTargets = eligibleTargets.filter(p => p.name !== excludePlayer);
             }
             // Additional filtering
             if (actionType === 'lynch' && gameState.blumenkindSavedPlayer) {
                  eligibleTargets = eligibleTargets.filter(p => p.name !== gameState.blumenkindSavedPlayer);
                  if (eligibleTargets.length > 0) { // Add info if player was saved
                      dayActionPromptP.innerHTML += `<br><i>(${escapeHTML(gameState.blumenkindSavedPlayer)} wurde vom Blumenkind gerettet.)</i>`;
                  }
             }


             dayActionTargetListUl.dataset.actionType = actionType;
             dayActionTargetListUl.dataset.maxSelections = maxSelections; // Store max selections

             if (eligibleTargets.length === 0) {
                 dayActionTargetListUl.innerHTML = '<li class="target-dead">Keine gültigen Ziele verfügbar.</li>';
                  // Disable confirm unless 0 selections are valid (AKW)
                  dayActionConfirmBtn.disabled = !(actionType === 'akw');
             } else {
                 eligibleTargets.forEach(player => {
                     const li = document.createElement('li');
                     li.dataset.playerName = player.name;
                     li.textContent = escapeHTML(player.name);
                     // Add dead class if needed (shouldn't happen with getLivingPlayers, but safety)
                     if (player.status !== 'Lebend') li.classList.add('target-dead');
                     else li.addEventListener('click', () => handleTargetSelection(li, actionType, maxSelections)); // Pass maxSelections here too
                     dayActionTargetListUl.appendChild(li);
                 });
                 // Disable confirm initially unless 0 selections are valid (AKW)
                 dayActionConfirmBtn.disabled = !(actionType === 'akw');
             }
        }


        // --- Day Action Confirmation (mostly unchanged logic) ---
        function handleDayActionConfirm(actionType) {
             if (gameState.gameOver || !actionType) return;
             const selectedTargets = Array.from(dayActionTargetListUl.querySelectorAll('.selected-target')).map(li => li.dataset.playerName);

             console.log(`Day Action Confirmed: ${actionType}`, selectedTargets);
             let wasNightTrigger = false; // Flag for AKW logic

             switch (actionType) {
                 case 'mayor':
                     if (selectedTargets.length === 1) {
                         stopDayTimer(); // Stop timer after mayor confirmed
                         gameState.buergermeister = selectedTargets[0];
                         const mayorPlayer = getPlayerData(gameState.buergermeister);
                         if (mayorPlayer) mayorPlayer.isBuergermeister = true;
                         console.log(`Bürgermeister gewählt: ${gameState.buergermeister}`);
                         renderGmPlayerList(); // Update GM list with crown

                         // --- MODIFIED: Go back to discussion after Mayor vote on Day 1 ---
                         console.log("Day 1: Mayor elected. Proceeding to Lynch Process.");
                         // Check Blumenkind -> Lynch Vote path
                          if (!gameState.blumenkindUsedSave && isRoleActive('blumenkind')) {
                              gameState.gamePhaseState = 'DAY_BLUMENKIND_SAVE';
                              setupBlumenkindSaveUI();
                              // No timer needed for blumenkind choice
                          } else {
                              gameState.gamePhaseState = 'DAY_LYNCH_VOTE';
                              setupLynchVoteUI();
                              startDayTimer(); // Start timer for lynch vote
                          }
                         // gameState.gamePhaseState = 'DAY_DISCUSSION';
                         // startDayTimer(); // Restart timer for lynch discussion
                     } else { console.error("Bürgermeisterwahl Fehler: Keine oder mehrere Ziele ausgewählt."); }
                     break;

                 case 'blumenkind_save': // Confirmed save target
                     if (selectedTargets.length === 1) {
                         gameState.blumenkindSavedPlayer = selectedTargets[0];
                         gameState.blumenkindUsedSave = true;
                         console.log(`Blumenkind rettet: ${gameState.blumenkindSavedPlayer}. Fähigkeit benutzt.`);
                         // Add info to results display?
                         dayResultsDisplayDiv.innerHTML += `<p>🌸 ${escapeHTML(gameState.blumenkindSavedPlayer)} wurde vom Blumenkind gerettet!</p>`;
                         dayResultsDisplayDiv.style.display = 'block';

                         gameState.gamePhaseState = 'DAY_LYNCH_VOTE'; // Proceed to lynch vote
                         setupLynchVoteUI();
                     } else { console.error("Blumenkind Rettung Fehler: Kein Ziel ausgewählt."); }
                     break;

                 case 'lynch':
                      if (selectedTargets.length === 1) {
                          stopDayTimer(); // Stop timer after lynch target confirmed
                          gameState.lynchTarget = selectedTargets[0]; // Set target for confirmation
                          console.log(`Lynchziel ausgewählt: ${gameState.lynchTarget}`);
                          gameState.gamePhaseState = 'DAY_LYNCH_CONFIRM';
                          setupLynchConfirmUI(gameState.lynchTarget);
                      } else { console.error("Lynchabstimmung Fehler: Kein oder mehrere Ziele ausgewählt."); }
                     break;

                 case 'lynch_confirm':
                     console.log(`Confirming lynch for ${gameState.lynchTarget}`);
                     const lynchTargetName = gameState.lynchTarget; // Store before potential death clears it
                      const lynchTargetData = getPlayerData(lynchTargetName); // Get data before death
                      gameState.lynchVictimRole = lynchTargetData?.roleData?.name || '?'; // Store role *before* death

                     let lynchSuccessful = applyDeath(lynchTargetName, 'lynch');
                     // Check if game ended during applyDeath (e.g., lover cascade)
                     if (gameState.gameOver) return;

                     if (lynchSuccessful) {
                         // Add lynch result to day display
                         dayResultsDisplayDiv.innerHTML += `<p>⚖️ Gelyncht: ${escapeHTML(lynchTargetName)} (${escapeHTML(gameState.lynchVictimRole)})</p>`;
                         dayResultsDisplayDiv.style.display = 'block';

                           // Re-check win conditions immediately after lynch death + lover cascade
                           if (checkWinConditions()) {
                                console.log("Game ended after lynch confirmation + lover check.");
                                updatePhaseDisplayAndControls();
                                return; // Stop further processing
                           }

                           // ***** FIX: Check gamePhaseState instead of pending flags *****
                           if (gameState.gamePhaseState === 'JAEGER_SHOT' || gameState.gamePhaseState === 'AKW_SELECTION') {
                                console.log("Lynch triggered Jaeger/AKW effect. Handling that next.");
                                // State was already set by applyDeath->triggerEffect
                                // The UI needs to be updated to show the Jaeger/AKW interface
                                updatePhaseDisplayAndControls();
                                return; // ***** Stop here, wait for effect resolution *****
                           }

                           // If no pending effects, proceed to Reinigungskraft check
                           if (!gameState.reinigungskraftUsedClean && isRoleActive('reinigungskraft')) {
                                 gameState.gamePhaseState = 'DAY_REINIGUNGSKRAFT';
                                 setupReinigungskraftUI();
                           } else {
                                 // No Reinigungskraft or already used, finish day
                                 console.log("Lynch role will be revealed (Reinigungskraft inactive/used).");
                                 gameState.hideLynchRole = false; // Ensure reveal happens if not hidden
                                 finishDayPhase();
                           }
                     } else {
                          // Lynch failed (e.g., player already dead), something went wrong
                          console.error("Lynch failed, target likely already dead.");
                          finishDayPhase(); // Try to recover
                     }
                     break; // End lynch_confirm case

                 case 'jaeger':
                     if (selectedTargets.length === 1) {
                         gameState.hunterTarget = selectedTargets[0];
                         const jaegerName = gameState.hunterVictim || '?';
                         console.log(`Jäger (${jaegerName}) schießt auf ${gameState.hunterTarget}`);

                          dayResultsDisplayDiv.innerHTML += `<p>🎯 Jäger (${escapeHTML(jaegerName)}) schoss auf ${escapeHTML(gameState.hunterTarget)}!</p>`;
                         dayResultsDisplayDiv.style.display = 'block';

                         let shotSuccessful = applyDeath(gameState.hunterTarget, 'jaeger_shot', jaegerName);
                         // Check if game ended during applyDeath
                         if (gameState.gameOver) return;

                         gameState.pendingHunterShot = false;
                         gameState.hunterVictim = null;

                         // Check for AKW cascade
                         if (gameState.gamePhaseState === 'AKW_SELECTION') {
                             console.log("Jaeger shot triggered AKW effect. Handling that next.");
                             updatePhaseDisplayAndControls();
                             return; // Stop here
                         }
                         // Finish day otherwise
                         finishDayPhase(); // finishDayPhase checks game over
                     } else { console.error("Jäger Schuss Fehler: Kein Ziel ausgewählt."); }
                     break;

                case 'akw':
                     gameState.akwSelectedNeighbors = selectedTargets; // Store selected neighbors (can be 0, 1 or 2)
                     const akwPlayerName = gameState.akwVictim || '?';
                     console.log(`AKW (${akwPlayerName}) Effekt trifft: ${selectedTargets.join(', ') || 'Niemanden'}`);
                     wasNightTrigger = gameState.currentPhase === 'Nacht'; // Check if this AKW was triggered at night

                     dayResultsDisplayDiv.innerHTML += `<p>💥 AKW (${escapeHTML(akwPlayerName)}) Effekt tötet: ${selectedTargets.map(escapeHTML).join(', ') || 'Niemanden'}</p>`;
                     dayResultsDisplayDiv.style.display = 'block';

                     let akwDeathsOccurred = false;
                     for (const neighborName of selectedTargets) { // Use for...of for early exit
                          if(applyDeath(neighborName, 'akw_effect', akwPlayerName)) {
                              akwDeathsOccurred = true;
                          }
                          // Check if game ended during applyDeath cascade
                          if (gameState.gameOver) return;
                     }

                     gameState.pendingAkwSelection = false;
                     gameState.akwVictim = null;
                     gameState.akwSelectedNeighbors = [];

                     // Check for Jaeger cascade
                     if (gameState.gamePhaseState === 'JAEGER_SHOT') {
                          console.log("AKW effect triggered Jaeger shot. Handling that next.");
                           if (!wasNightTrigger) {
                               updatePhaseDisplayAndControls();
                               return; // Stop here
                           }
                     }

                     // Handle night trigger or finish day
                     if (wasNightTrigger) {
                          console.log("AKW effect (triggered at night) resolved. Proceeding to show night results.");
                          gameState.gamePhaseState = 'NIGHT_RESULTS';
                          displayNightResults();
                          renderGmPlayerList();
                          // checkWinConditions called inside endNightActions flow isn't strictly needed here
                          // but ensure UI update reflects potential game over
                          if (!checkWinConditions()) { // Check if game ended AFTER AKW resolved
                               updatePhaseDisplayAndControls(); // Show 'Start Day' button
                          } else {
                               updatePhaseDisplayAndControls(); // Ensure Game Over is shown
                               return; // Stop if game ended
                          }
                     } else {
                          // AKW triggered during day, finish day phase
                          finishDayPhase(); // finishDayPhase checks game over
                     }
                     break; // End AKW case

                 default:
                     console.error("Unbekannter Tagesaktionstyp für Bestätigung:", actionType);
             }

             // Final UI update if game didn't end and wasn't handled by returns above
             if (!gameState.gameOver) {
                  updatePhaseDisplayAndControls();
             }
        }

        // --- Day Action Skip (mostly unchanged logic) ---
        function handleDayActionSkip(actionType) { // Pass actionType explicitly
             if (actionType === 'lynch_cancel') {
                 console.log("Lynch cancelled.");
                 gameState.lynchTarget = null; // Clear target
                 // Go back to Lynch Vote step
                 gameState.gamePhaseState = 'DAY_LYNCH_VOTE';
                 setupLynchVoteUI();
                 updatePhaseDisplayAndControls();
             } else {
                 console.warn("Skip button used in unexpected state/action:", gameState.gamePhaseState, actionType);
             }
        }


        // --- Specific Day Action Handlers (mostly unchanged logic) ---
        // ... (handleBlumenkindChoice, handleReinigungskraftChoice, finishDayPhase) ...
         function handleBlumenkindChoice(saveChoice) {
              if (gameState.gamePhaseState !== 'DAY_BLUMENKIND_SAVE' || gameState.blumenkindUsedSave) return;

              if (saveChoice) {
                   // Player wants to save, show target list
                   dayActionTitleH4.textContent = "Blumenkind Rettung";
                   dayActionPromptP.textContent = "Wähle den Spieler, den du retten möchtest.";
                   renderDayActionTargetList('blumenkind_save'); // New action type for save target
                   dayActionConfirmBtn.textContent = "Rettung bestätigen";
                   dayActionConfirmBtn.disabled = true;
                   dayActionConfirmBtn.style.display = 'inline-block';
                   dayActionConfirmBtn.dataset.actionType = 'blumenkind_save'; // Set action type for confirm
                   blumenkindSaveAreaDiv.style.display = 'none'; // Hide Yes/No
                   dayActionSkipBtn.style.display = 'none'; // Hide skip when selecting target
              } else {
                   // Player chose not to save this time
                   console.log("Blumenkind chose not to save.");
                   gameState.blumenkindSavedPlayer = null; // Ensure no one is saved
                   gameState.gamePhaseState = 'DAY_LYNCH_VOTE'; // Proceed to lynch vote
                   setupLynchVoteUI();
                   updatePhaseDisplayAndControls();
              }
         }

          function handleReinigungskraftChoice(hideChoice) { // Yes = Hide Role, No = Reveal Role
              if (gameState.gamePhaseState !== 'DAY_REINIGUNGSKRAFT' || gameState.reinigungskraftUsedClean) return;

              gameState.hideLynchRole = hideChoice;
              gameState.reinigungskraftUsedClean = true; // Mark ability used regardless of choice
              console.log(`Reinigungskraft chose to ${hideChoice ? 'hide' : 'reveal'} the role of ${gameState.lynchTarget}. Ability used.`);

              // Update GM list immediately to reflect potential hidden role
              renderGmPlayerList();

               // Add info to day results display
               dayResultsDisplayDiv.innerHTML += `<p>🧼 Reinigungskraft hat entschieden, die Rolle ${hideChoice ? 'zu verbergen' : 'bekannt zu geben'}.</p>`;
               dayResultsDisplayDiv.style.display = 'block';


              // Proceed to end day/start night
              finishDayPhase();
              updatePhaseDisplayAndControls();
          }

          function finishDayPhase() {
               console.log("Finishing Day Phase actions.");
               // Called after lynch (+ optional Reinigungskraft), or after Jaeger/AKW resolution that occurred during the day

               // Safety check for pending effects (should have been handled before calling this)
               if (gameState.pendingHunterShot || gameState.pendingAkwSelection) {
                   console.warn("FinishDayPhase called while effects still pending. State:", gameState.gamePhaseState);
                   // The pending effect should be the current state, let it resolve.
                   updatePhaseDisplayAndControls(); // Ensure UI reflects pending state
                   return;
               }

                // NEW: Apply delayed bite deaths NOW, after all day actions/effects resolved
                const gameEndedByBite = applyEndOfDayDeaths();
                if (gameEndedByBite) {
                    console.log("Game ended after applying end-of-day bite deaths.");
                    updatePhaseDisplayAndControls(); // Ensure game over screen is shown
                    return;
                }

               // Final win condition check after all day actions and effects have resolved.
               if (!checkWinConditions()) {
                    // Game continues, prepare for next night
                    gameState.gamePhaseState = null; // Reset detailed state before showing button
                    gameState.currentPhase = 'Tag'; // Remain 'Tag' until night starts
                    // Update button text for next night
                    startNextNightBtn.textContent = `Nacht ${gameState.phaseNumber + 1} starten`;
                    startNextNightBtn.style.display = 'inline-block'; // Show button

                    dayActionAreaDiv.style.display = 'none'; // Hide day action area
                    dayTimerContainerDiv.style.display = 'none'; // Hide timer
                    startVoteBtn.style.display = 'none'; // Hide vote button
                    // Keep results visible for a moment? Or hide here? Let's hide action area.
                     updatePhaseDisplayAndControls(); // Update display (will hide day action, show next night btn)
               } else {
                    // Game ended, UI updated by endGame -> updatePhaseDisplayAndControls
                    console.log("Game ended during finishDayPhase check.")
               }
          }


        // --- Win Condition Check (mostly unchanged logic) ---
        // ... (checkWinConditions, endGame) ...
         function checkWinConditions() {
             if (gameState.gameOver) return true; // Don't re-check if already ended

             const livingPlayers = getLivingPlayers();
             const livingCount = livingPlayers.length;

             if (livingCount === 0) {
                  gameState.winner = 'Niemand';
                  console.log("Game Over: Niemand hat überlebt.");
                  endGame();
                  return true;
             }

             const livingFactions = {};
              let livingLoversCount = 0;
             livingPlayers.forEach(p => {
                  // Use current role's faction for checks
                  let faction = p.roleData.faction;
                  // Lovers are special: their win condition depends ONLY on them surviving together
                  if (gameState.loverPair.includes(p.name)) {
                      livingLoversCount++;
                      // Don't assign faction 'Liebende' here, check it explicitly below
                  } else {
                       // Only count non-lover factions here
                       livingFactions[faction] = (livingFactions[faction] || 0) + 1;
                  }
             });

             const vampiresCount = livingFactions['Vampir'] || 0;
             const wolvesCount = livingFactions['Werwolf'] || 0;
             const villageCount = livingFactions['Dorf'] || 0; // Count only non-lover villagers

             console.log("Checking win conditions. Living count:", livingCount, "Factions:", livingFactions, "Living Lovers:", livingLoversCount);


             // 1. Lover Win (Highest Priority)
              // Check if ONLY the lovers remain AND both are alive
              if (livingLoversCount === 2 && livingCount === 2) {
                  // Check if the two living players ARE the lovers
                  const livingNames = livingPlayers.map(p => p.name);
                  if (gameState.loverPair.every(lover => livingNames.includes(lover))) {
                      gameState.winner = 'Liebende';
                      console.log("Game Over: Liebende gewinnen!");
                      endGame();
                      return true;
                  }
              }

             // Check if lovers *could* win (both alive) - affects other win conditions
             const loversCanWin = livingLoversCount === 2;


             // 2. Vampire Win
             // Vampires win if they exist, no wolves exist, and no non-vampire players exist (excluding potential winning lovers)
              if (vampiresCount > 0 && wolvesCount === 0 && villageCount === 0 && !loversCanWin) {
                  gameState.winner = 'Vampir';
                  console.log("Game Over: Vampire gewinnen (Elimination)!");
                  endGame();
                  return true;
              }
             // Vampires win if they are the majority against remaining non-wolf, non-lover villagers
             // This might be complex depending on rules vs wolves; Elimination is safer.


             // 3. Werewolf Win
             // Wolves win if they exist, no vampires exist, and no non-wolf players exist (excluding potential winning lovers)
              if (wolvesCount > 0 && vampiresCount === 0 && villageCount === 0 && !loversCanWin) {
                  gameState.winner = 'Werwolf';
                  console.log("Game Over: Werwölfe gewinnen (Elimination)!");
                  endGame();
                  return true;
              }
             // FIX 2: Wolf Majority Win - only triggers if ONLY wolves and (non-lover) villagers remain
              if (wolvesCount > 0 && vampiresCount === 0 && !loversCanWin && livingCount === (wolvesCount + villageCount)) {
                  // Check if wolves are majority or equal
                  if (wolvesCount >= villageCount) {
                     gameState.winner = 'Werwolf';
                     console.log("Game Over: Werwölfe gewinnen (Majority vs Dorf)!");
                     endGame();
                     return true;
                  }
              }


             // 4. Village Win
             // All Werewolves and Vampires are dead. Lovers didn't win.
              if (wolvesCount === 0 && vampiresCount === 0 && villageCount > 0 && !loversCanWin) {
                   gameState.winner = 'Dorf';
                   console.log("Game Over: Dorf gewinnt!");
                   endGame();
                   return true;
              }

              return false; // No win condition met yet
         }

         function endGame(context = null) { // Add context parameter
              console.log("Ending game. Winner:", gameState.winner, "Context:", context);
              if (gameState.gameOver) return; // Prevent double trigger

              gameState.gameOver = true;
              gameState.gamePhaseState = 'GAME_OVER';
              stopDayTimer(); // Stop timer if running

              let message = "";
              // Add specific prefix if ended overnight
              if (context === 'overnight') {
                  message += "Spiel endete während der Nachtberechnungen.<br>"; // Prefix added here
              } else {
                 message += "Das Spiel ist vorbei!<br>";
              }

              switch(gameState.winner) { // Winner message appended here
                  case 'Dorf': message += "Das Dorf hat gewonnen!"; break;
                  case 'Werwolf': message += "Die Werwölfe haben gewonnen!"; break;
                  case 'Liebende': message += `Das Liebespaar (${gameState.loverPair.map(escapeHTML).join(' & ')}) hat gewonnen!`; break;
                  case 'Vampir': message += "Die Vampire haben gewonnen!"; break;
                  default: message += "Niemand hat überlebt...";
              }
              gameOverMessageH3.innerHTML = message; // Full message assigned to UI element
               renderGmPlayerList(); // Final update of player list state
              updatePhaseDisplayAndControls(); // Show game over screen, hide controls
         }

        // --- Restart Game (unchanged logic) ---
        function restartGame() {
             console.log("Restarting game...");
             // Reset all state and go back to setup view
             gameState = {}; // Clear game state
             players = [];
             initialPlayerOrder = [];
             roles = {};
             assignedRoles = [];
             switchView('setup');
        }


        // --- Event Listeners ---

        // Setup & Reveal
        addPlayerBtn.addEventListener('click', addPlayer);
        playerNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addPlayer(); });
        playerListUl.addEventListener('click', (e) => {
            if (e.target.classList.contains('remove-player-btn')) removePlayer(parseInt(e.target.getAttribute('data-index'), 10));
        });
        // Updated: Listener for role card interactions
        roleSelectionListDiv.addEventListener('click', (e) => {
             const quantityButton = e.target.closest('.role-quantity button');
             const infoButton = e.target.closest('.info-btn');

             if (quantityButton) {
                 handleRoleCountChange(quantityButton.getAttribute('data-role-id'), parseInt(quantityButton.getAttribute('data-change'), 10));
             } else if (infoButton) {
                 showRoleInfo(infoButton.getAttribute('data-role-id'));
             }
         });
        assignRolesBtn.addEventListener('click', assignRolesAndStartReveal);
        revealRoleBtn.addEventListener('click', revealRole);
        toggleLangBtn.addEventListener('click', toggleLanguage);
        hideRoleBtn.addEventListener('click', hideRoleAndProceed);
        switchToFacilitationBtn.addEventListener('click', switchToFacilitation);

        // Role Info Modal Listeners
        modalCloseBtn.addEventListener('click', hideRoleInfo);
        modalLangToggle.addEventListener('click', toggleModalLanguage);
        // Close modal if clicking outside the content
        roleInfoModal.addEventListener('click', (e) => {
            if (e.target === roleInfoModal) { // Check if the click is on the background overlay
                hideRoleInfo();
            }
        });


        // Facilitation - Phase Controls
        startNightBtn.addEventListener('click', startNightPhase);
        startDayBtn.addEventListener('click', startDayPhase);
        startVoteBtn.addEventListener('click', startVotingProcess);
        startNextNightBtn.addEventListener('click', startNightPhase);
        restartGameBtn.addEventListener('click', restartGame);


        // Facilitation - Night Actions
        nightActionNextBtn.addEventListener('click', handleNightActionNext);
        nightActionConfirmBtn.addEventListener('click', confirmNightAction);
        // Updated: Use actionType from dataset for skip button
        nightActionSkipBtn.addEventListener('click', (e) => {
             handleNightSkip(e.target.dataset.actionType);
         });


        // Hexe Potion Buttons
        hexeActionAreaDiv.addEventListener('click', (e) => {
             if (e.target.tagName === 'BUTTON' && e.target.dataset.potion) {
                 handleHexePotionClick(e.target.dataset.potion, e.target.dataset.action);
             }
        });
        // Target list clicks handled within render functions attaching listeners

        // Facilitation - Day Actions
        dayActionConfirmBtn.addEventListener('click', (e) => {
            // Use the data attribute on the button to determine the action
            const actionType = e.target.dataset.actionType;
             if (actionType) {
                 handleDayActionConfirm(actionType); // Pass the determined type
             } else {
                 console.error("Could not determine day action type for confirmation from button attribute.");
             }
        });
        dayActionSkipBtn.addEventListener('click', (e) => { // Lynch cancel etc.
            const actionType = e.target.dataset.actionType; // Get type from button
            if (actionType) {
                 handleDayActionSkip(actionType); // Pass the determined type
             } else {
                 console.error("Could not determine day action type for skip/cancel from button attribute.");
             }
        });

         // Blumenkind Yes/No Buttons
         blumenkindSaveAreaDiv.addEventListener('click', (e) => {
             if (e.target.tagName === 'BUTTON' && e.target.dataset.choice) {
                  // Pass choice directly ('yes'/'no')
                 handleBlumenkindChoice(e.target.dataset.choice === 'yes');
             }
         });

         // Reinigungskraft Yes/No Buttons
         reinigungskraftChoiceAreaDiv.addEventListener('click', (e) => {
              if (e.target.tagName === 'BUTTON' && e.target.dataset.choice) {
                   // Pass choice directly ('yes'/'no') - Yes = Hide Role
                  handleReinigungskraftChoice(e.target.dataset.choice === 'yes');
              }
         });


        // --- Initial Setup ---
        renderRoleSelection(); // Initial render of new cards
        updateValidation();
        gameState.gamePhaseState = 'SETUP'; // Initial state
        switchView('setup');

        // --- Delayed Bite Death Application --- - MOVED this logic to end of day
        // ... (function removed) ...


        // --- NEW: End of Day Death Application (for delayed effects like bite) ---
        function applyEndOfDayDeaths() {
            console.log("Checking for end-of-day deaths (Vampire Bites)...");
            let deathOccurred = false;
            let gameEnded = false;
            const playersToKill = gameState.players.filter(p => p.isBitten && p.status === 'Lebend');
            let endOfDayMessages = []; // Collect messages for display
            let endOfDayGmNotes = []; // Collect GM notes for these deaths

            if (playersToKill.length > 0) {
                 console.log("Players dying from bite at end of day:", playersToKill.map(p => p.name));
                 playersToKill.forEach(player => {
                      const playerRoleAtDeath = player.roleData?.name || '?'; // Get role before potential death
                      if (player.status === 'Lebend' && !gameEnded) { // Only proceed if player still alive and game not ended by previous bite/cascade
                          console.log(`Applying end-of-day bite death to ${player.name}`);
                          if (applyDeath(player.name, 'vampir_bite')) { // applyDeath handles lovers, effects, win checks
                              deathOccurred = true;
                              // NEW: Add message for GM display
                              const message = `🩸 ${escapeHTML(player.name)} (${escapeHTML(playerRoleAtDeath)}) erlag am Ende des Tages dem Vampirbiss!`;
                              endOfDayMessages.push(message);
                              // ADDED: Explicit GM Note - UPDATED TEXT
                              const gmNote = `<i>GM Info (Vampirbiss): ${escapeHTML(player.name)} ist wegen des Vampirbisses von letzter Nacht gestorben! Informiere den Spieler.</i>`;
                              endOfDayGmNotes.push(gmNote);

                              // Check if this death ended the game immediately
                              gameEnded = gameState.gameOver;
                          }
                          player.isBitten = false; // Clear flag *after* applying death
                      } else {
                           console.log(`Skipping bite death for ${player.name} (already dead or game ended)`);
                           player.isBitten = false; // Clear flag even if not killed now
                      }
                 });

                  // NEW: Display end-of-day death messages AND GM notes in the day results area
                  if (endOfDayMessages.length > 0 || endOfDayGmNotes.length > 0) {
                      // Check if results div exists and is visible, otherwise create/show it? For now, just append.
                      if (!dayResultsDisplayDiv.querySelector('h4')) { // Add header if missing
                          dayResultsDisplayDiv.innerHTML = '<h4>Tagesereignisse</h4>'; // Use a more general header if needed
                      }
                      // Append public messages first
                      if (endOfDayMessages.length > 0) {
                          dayResultsDisplayDiv.innerHTML += endOfDayMessages.map(msg => `<p>${msg}</p>`).join('');
                      }
                      // Append GM notes
                      if (endOfDayGmNotes.length > 0) {
                          dayResultsDisplayDiv.innerHTML += endOfDayGmNotes.map(note => `<p class="gm-note">${note}</p>`).join('');
                      }
                      dayResultsDisplayDiv.style.display = 'block'; // Ensure visible
                  }

                  if (deathOccurred) {
                      renderGmPlayerList(); // Update list after all bite deaths applied
                  }
            } else {
                console.log("No players succumbed to bite at end of day.");
            }
            return gameEnded; // Return true if any death during this process ended the game
        }

        // --- NEW: On-Page Console Function ---
        function logToConsole(message, type = 'log') {
             if (!consoleOutputPre) return; // Safety check

             const line = document.createElement('div');
             line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
             if (type === 'warn') line.classList.add('log-warn');
             else if (type === 'error') line.classList.add('log-error');

             consoleOutputPre.appendChild(line);

             // Limit lines
             while (consoleOutputPre.childNodes.length > MAX_CONSOLE_LINES) {
                 consoleOutputPre.removeChild(consoleOutputPre.firstChild);
             }
             // Scroll to bottom
             onPageConsoleDiv.scrollTop = onPageConsoleDiv.scrollHeight;
        }

        function toggleConsole() {
            isConsoleVisible = !isConsoleVisible;
            onPageConsoleDiv.style.display = isConsoleVisible ? 'block' : 'none';
            toggleConsoleBtn.textContent = isConsoleVisible ? 'Konsole verbergen' : 'Konsole anzeigen';
            toggleConsoleBtn.classList.toggle('active', isConsoleVisible);
             if (isConsoleVisible) {
                logToConsole("Konsole geöffnet.");
                // Optional: Scroll to bottom immediately
                onPageConsoleDiv.scrollTop = onPageConsoleDiv.scrollHeight;
            }
        }

        // --- Override console.log etc. (Optional but useful) ---
        const originalConsoleLog = console.log;
        const originalConsoleWarn = console.warn;
        const originalConsoleError = console.error;

        console.log = function(...args) {
            originalConsoleLog.apply(console, args);
            logToConsole(args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' '), 'log');
        };
        console.warn = function(...args) {
            originalConsoleWarn.apply(console, args);
            logToConsole(args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' '), 'warn');
        };
        console.error = function(...args) {
            originalConsoleError.apply(console, args);
            logToConsole(args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' '), 'error');
        };
        // --- End Console Override ---


        // --- Event Listeners ---

        // ... (existing listeners) ...

        // NEW: Console Toggle Listener
        toggleConsoleBtn.addEventListener('click', toggleConsole);


        // --- Initial Setup ---
        // ... (existing code ...
    </script>

</body>
</html>